---
title: '面试'
tags:
    - 面试
---

# ali
- aop的实现原理
- 线程状态
- 常用设计模式有些
- mysql数据库有哪些索引

# tencent music
- tcp中的滑动窗口
- python中的dict和list线程安全吗?
- 2个链表是否有交叉？

# >_<
- aop的实现原理
> - 动态代理：采用反射技术
- 线程状态
> - 6个状态定义: java.lang.Thread.State
> - `New`: 尚未启动的线程的线程状态。
> - `Runnable`: 可运行线程的线程状态，等待CPU调度。
> - `Blocked`: 线程阻塞等待监视器锁定的线程状态。处于synchronized同步代码块或方法中被阻塞。
> - `Waiting`: 等待线程的线程状态。下列不带超时的方式:Object.wait、Thread.join、 LockSupport.park
> - `Timed Waiting`:具有指定等待时间的等待线程的线程状态。下列带超时的方式:Thread.sleep、0bject.wait、 Thread.join、 LockSupport.parkNanos、 LockSupport.parkUntil
> - `Terminated`: 终止线程的线程状态。线程正常完成执行或者出现异常。
- 常用设计模式有些
> - **创建型**
> - `单例模式`：唯一实例。
> - `工厂方法模式`：创建对象不会对客户端暴露创建逻辑，通过传参获取实例。
> - 抽象工厂模式
> - `建造者模式`：使用多个简单的对象一步一步构建成一个复杂对象。
> - 原型模式：使用实例拷贝，实现Cloneable。
> - **结构型**
> - `适配器模式`：两个不兼容的接口之间的桥梁。
> - `桥接模式`：将抽象部分与实现部分分离，使它们可以独立变化。
> - `组合模式`：将对象组合成树型结构以表示“部分-整体”的层次结构，对象包含该对象的数组。
> - `装饰模式`：向现有的对象添加新功能。
> - 外观模式
> - `享元模式`：运用共享技术有效减少对象的创建。
> - `代理模式`：一个类代表另一个类的功能。
> - **行为型**
> - `访问者模式`：被访问的类提供不同访问者各自不同的功能。
> - `模板模式`：定义一个操作的骨架（抽象类），具体由子类实现。
> - 策略模式
> - 状态模式
> - `观察者模式`：当一个对象被修改时，会通知订阅者。（当对象存在一对多的关系时使用）
> - 备忘录模式
> - 中介者模式
> - 迭代其模式
> - 解释器模式
> - `命令模式`：将请求封装成一个接口，具体的操作由子类实现。
> - `责任链模式`：避免接收者与发送者耦合，让多个对象都有可能接收请求，将这些对象连接成一条链，并沿着这条链传递请求，每个接收者都可对其处理并转发。
- mysql数据库有哪些索引
> - https://www.cnblogs.com/shoshana-kong/p/10517488.html
> - **从数据结构角度**
> - 1、B+树索引(O(log(n)))
> - 2、hash索引
> - 3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）
> - 4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）
> - **从物理存储角度**
> - 1、聚集索引（clustered index）
> - 2、非聚集索引（non-clustered index）
> - **从逻辑角度**
> - 1、主键索引
> - 2、普通索引或者单列索引
> - 3、多列索引（复合索引）
> - 4、唯一索引或者非唯一索引
> - 5、空间索引


- tcp中的滑动窗口
> - 为了避免一次性发送大量数据导致网络压力，造成丢包重试。
> - 故TCP将数据包一批一批的发送，就像窗口一样，不停后移。窗口大小也不是固定的，是握手后调整的。
> - 将发送的数据包排成队列，分4类。`窗口前的(已发送)`：已发送给接收方，并且已收到接收方的答复;`窗口中的(未确认,未发送)`：分2种，一种是已发送给接收方，但未收到接收方的确认。另一种是可以发送，但还没有发送;`窗口后的(不可发送)`：串口还未滑到的，不允许发送的。
- python中的dict和list线程安全吗?
> - 安全。
- 2个链表是否有交叉？
> - `方法1（移动到同一起跑点）`：如果两个链表有公共节点，那么该公共节点之后的所有节点都是两个链表所共有的，所以长度一定也是相等的。如果两个链表的总长度是相等的，那么对两个链表进行遍历，则一定同时到达第一个公共节点。但是链表的长度实际上不一定相同，所以我们只需要计算出两个链表的长度之差n，然后让长的那个链表先移动n步，短的链表再开始向后遍历，这样他们一定同时到达第一个公共节点，我们只需要在向后移动的时候比较两个链表的节点是否相等就可以获得第一个公共节点。时间复杂度是O(m+n)
> - `方法2（将其中一个连成环）`：将其中一个链表的首尾相连，然后判断另一个链表是否含环。如果含环，则两链表交叉；否则，不交叉。时间复杂度是O(max[m,n])
> - `ps`：两个不同步长指针是判断1个链表是否有环。

