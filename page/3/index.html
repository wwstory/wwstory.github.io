<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="你根本不知道你什么都不知道">
<meta property="og:type" content="website">
<meta property="og:title" content="枫の故事">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="枫の故事">
<meta property="og:description" content="你根本不知道你什么都不知道">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dejiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>枫の故事</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫の故事</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">纸上得来终觉浅，绝知此事要恭行</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<!--
<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
-->
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/note/book-list-readed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/01/note/book-list-readed/" class="post-title-link" itemprop="url">book list - readed</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-01T00:00:00+08:00">2019-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index">
                    <span itemprop="name">note</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="minder-view" minder-data-type="json" style="width:100%; height:10000px;">
{"root":{"data":{"id":"134b381888bd","created":1566956099,"text":"书单"},"children":[{"data":{"id":"bwkvl51dr2g0","created":1566956122502,"text":"C/C++"},"children":[{"data":{"id":"bwkvrtb4c9s0","created":1566956645518,"text":"C Primer Plus","image":"http://kityminder-img.gz.bcebos.com/fe3b13e9b49bd6afe72e5b7c76bbe3cc41b66719","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkvrxgay480","created":1566956654539,"text":"C++ Primer Plus","image":"http://kityminder-img.gz.bcebos.com/3c39e5b69f99e4963d890689f541ea2370bda229","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]}]},{"data":{"id":"bwkvl8wkzb40","created":1566956130919,"text":"代码"},"children":[{"data":{"id":"bxbid19rhd6o","created":1569660931789,"text":"图解设计模式","image":"http://kityminder-img.gz.bcebos.com/81b9215dce3160b4a24a2a0072321d89c7bf5692","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]}]},{"data":{"id":"bwkvle1arz40","created":1566956142088,"text":"Java","expandState":"expand"},"children":[{"data":{"id":"bwkvmbwcn5c0","created":1566956215799,"text":"Java基础","expandState":"expand"},"children":[{"data":{"id":"bwkvscyv1zc0","created":1566956688313,"text":"Java 8编程参考官方教程(第9版)","image":"http://kityminder-img.gz.bcebos.com/3597d69f5d304174e857e7ebf01f84aece30c0a6","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvt1divvk0","created":1566956741442,"text":"码农翻身","image":"http://kityminder-img.gz.bcebos.com/d74d3a9f8e68aa00c41073c80d026f24ac15e78c","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvme9xzk00","created":1566956220975,"text":"JVM"},"children":[{"data":{"id":"bwkvst045ww0","created":1566956723217,"text":"深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）","image":"http://kityminder-img.gz.bcebos.com/d5531736ca642d7e77626568a9a906fe8f6a637d","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]}]},{"data":{"id":"bwkvli75q3k0","created":1566956151149,"text":"Spring"},"children":[{"data":{"id":"bwkvtp4air40","created":1566956793127,"text":"Spring实战（第4版）","image":"http://kityminder-img.gz.bcebos.com/6848bcf18ec91e0f97b7264eb6c8cccb7bbfcc34","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtrd64680","created":1566956798017,"text":"Spring Boot实战","image":"http://kityminder-img.gz.bcebos.com/9641bef0ec2e185e6b76c6c26d4220fe6c312114","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtuoor5k0","created":1566956805244,"text":"Spring微服务实战","image":"http://kityminder-img.gz.bcebos.com/dfee4134feef3b89dd5a5d31b6d0c5207b5e6e2a","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtx90o9k0","created":1566956810827,"text":"Spring Data实战","image":"http://kityminder-img.gz.bcebos.com/271cd38418aafe495eaef59e53d454a459e870f8","imageTitle":"","imageSize":{"width":152,"height":200}},"children":[]}]},{"data":{"id":"bwkvlr83sg80","created":1566956170798,"text":"分布式"},"children":[{"data":{"id":"bwkvu8bucnk0","created":1566956834942,"text":"深入理解Nginx：模块开发与架构解析（第2版）","image":"http://kityminder-img.gz.bcebos.com/9a95a05c87ee92907bbaf6160e972ab3d8324e17","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvuavjqr40","created":1566956840487,"text":"深入浅出Docker","image":"http://kityminder-img.gz.bcebos.com/f305241a55947b9343bbd2461f5ca70e709e6bad","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]}]},{"data":{"id":"bwkvmwat62o0","created":1566956260209,"text":"其它"},"children":[{"data":{"id":"bwkvvezmc4o0","created":1566956927805,"text":"Mybatis技术内幕","image":"http://kityminder-img.gz.bcebos.com/2ecfae24d4e26c3e298ac36bf75ca65d24473d0d","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]}]}]},{"data":{"id":"bwkvlo4q6g00","created":1566956164063,"text":"数据库"},"children":[{"data":{"id":"bwkvu04lkow0","created":1566956817090,"text":"MySQL技术内幕：InnoDB存储引擎（第2版）","image":"http://kityminder-img.gz.bcebos.com/c1b83527c009f8c89ee5a119ece0ed0ba6588f0a","imageTitle":"","imageSize":{"width":133,"height":200}},"children":[]},{"data":{"id":"bwkvu56qpug0","created":1566956828103,"text":"Redis实战","image":"http://kityminder-img.gz.bcebos.com/80d8843d1e11bca2ff5aaa9841936f7df8faa0d9","imageTitle":"","imageSize":{"width":158,"height":200}},"children":[]}]},{"data":{"id":"bwkvlvgluls0","created":1566956180019,"text":"Python"},"children":[{"data":{"id":"bwkvugnt1pc0","created":1566956853080,"text":"Python并行编程参考手册","image":"http://kityminder-img.gz.bcebos.com/b9c1bf306b06837d1e1b6ae60d3d04fa913b0ce8","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]},{"data":{"id":"bwkvuibxhx40","created":1566956856715,"text":"Python高性能编程","image":"http://kityminder-img.gz.bcebos.com/68aa17db831e39d24121d0961dea22dc1894432f","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvukij5t40","created":1566956861468,"text":"Effective Python","image":"http://kityminder-img.gz.bcebos.com/4f7c939d73eeb118839ae3643aabe9f7b9baffca","imageTitle":"","imageSize":{"width":156,"height":200}},"children":[]},{"data":{"id":"bwkvuoyw1v40","created":1566956871164,"text":"自己动手写Python虚拟机","image":"http://kityminder-img.gz.bcebos.com/78d5638962bcfad452ad8487fea19e6a656e6f79","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvm16cav40","created":1566956192459,"text":"go","expandState":"expand"},"children":[{"data":{"id":"bxboiht39uo0","created":1569678286267,"text":"Go语言实战","expandState":"expand","image":"http://kityminder-img.gz.bcebos.com/488f7db5c0d687c99239b5d41c01c7b594980b0f","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]}]},{"data":{"id":"bwkvn7ojogw0","created":1566956284984,"text":"系统"},"children":[{"data":{"id":"bwkvvv05w8w0","created":1566956962666,"text":"鸟哥的Linux私房菜 基础学习篇 第四版","image":"http://kityminder-img.gz.bcebos.com/089b1c7443f53140799f38c67d58df069379e339","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvw1k6n680","created":1566956976937,"text":"编译原理（第2版）","image":"http://kityminder-img.gz.bcebos.com/790f4f21df0a786b3e1aff511276907519be1f06","imageTitle":"","imageSize":{"width":149,"height":200}},"children":[]},{"data":{"id":"bwkx8ygs7j40","created":1566960810046,"text":"操作系统 精髓与设计原理 ","image":"http://kityminder-img.gz.bcebos.com/725f016d7d2fb94e76e0d767823d7ee12f87b049","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkxe90y5vc0","created":1566961224853,"text":"计算机组成(第6版)","image":"http://kityminder-img.gz.bcebos.com/726c685d05c6ed58c9c3bf46ad44dace3a000aca","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkxfqmzv6w0","created":1566961341556,"text":"计算机网络(第6版)","image":"http://kityminder-img.gz.bcebos.com/57d5798a51745f0ccdbec72181ad0fb5fe0c0055","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]}]},{"data":{"id":"bwkvnwvycmo0","created":1566956339852,"text":"网络"},"children":[{"data":{"id":"bwkvwcis9000","created":1566957000797,"text":"图解HTTP","image":"http://kityminder-img.gz.bcebos.com/50874fc99ba25f44426534c1002e17ed63022775","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]},{"data":{"id":"bwkvwesvajs0","created":1566957005761,"text":"图解TCP/IP：第5版","image":"http://kityminder-img.gz.bcebos.com/665c74c1ddfa98c45a309d5ea046e60419844e54","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]}]},{"data":{"id":"bwkvnyvyw8o0","created":1566956344206,"text":"算法"},"children":[{"data":{"id":"bwkvwh36ho00","created":1566957010738,"text":"数据结构与算法分析：C语言描述","image":"http://kityminder-img.gz.bcebos.com/021b23779cd82851985e3347dc887011d1eb8df0","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwjecqjc0","created":1566957015767,"text":"算法导论","image":"http://kityminder-img.gz.bcebos.com/f250d3b4392617434509f7e7022b865d4f33c17c","imageTitle":"","imageSize":{"width":151,"height":200}},"children":[]},{"data":{"id":"bwkvwlgyya80","created":1566957020279,"text":"算法竞赛入门经典（第2版）","image":"http://kityminder-img.gz.bcebos.com/6867bf5cdedba9cdf832745b3d97d70b6e9e9ae4","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwmvvrw00","created":1566957023358,"text":"算法竞赛入门经典 训练指南","image":"http://kityminder-img.gz.bcebos.com/f095bab9c7f6ae27f54915ff7d8cc00700809eba","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwpdg4w80","created":1566957028773,"text":"算法图解","image":"http://kityminder-img.gz.bcebos.com/1424a93d83a888ab03a018d224d11c45c0a70554","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwqwi3080","created":1566957032102,"text":"漫画算法：小灰的算法之旅","image":"http://kityminder-img.gz.bcebos.com/5ca50dc902a819f7316a9dcaba64d461daca3ccf","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvo1hk2pk0","created":1566956349865,"text":"机器学习"},"children":[{"data":{"id":"bwkvwubm7f40","created":1566957039546,"text":"机器学习","image":"http://kityminder-img.gz.bcebos.com/31877ff7126872f2f560b4c168e058a2d553ee99","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwvpirvk0","created":1566957042564,"text":"Python神经网络编程","image":"http://kityminder-img.gz.bcebos.com/d2211092ac9a0f99293af2f06474f22e0d6eaaa8","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwxnwv680","created":1566957046820,"text":"TensorFlow：实战Google深度学习框架（第2版）","image":"http://kityminder-img.gz.bcebos.com/1cdea519b73766fd2cb5870111a0ea48e2485744","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwzwic140","created":1566957051693,"text":"深度学习框架PyTorch：入门与实践","image":"http://kityminder-img.gz.bcebos.com/7c284e0f06efa3aad2616a1b5943d71e4585f51a","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvx1alc140","created":1566957054722,"text":"生成对抗网络入门指南","image":"http://kityminder-img.gz.bcebos.com/1290e73cfef8f998c36574adcd86234da9aaea03","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvx37npmw0","created":1566957058898,"text":"深度学习","image":"http://kityminder-img.gz.bcebos.com/407d622d6b1e4589fd439cea365046bad19f1dbd","imageTitle":"","imageSize":{"width":166,"height":200}},"children":[]},{"data":{"id":"bwkvx4jszao0","created":1566957061809,"text":"机器学习实战","image":"http://kityminder-img.gz.bcebos.com/388d614a84efad18829fb359a11ac62eb3d6f784","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvx6cvzzs0","created":1566957065744,"text":"统计学习方法（第2版）","image":"http://kityminder-img.gz.bcebos.com/c57b6c3a6642c028d824fa742ecb8f0f307dfa04","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]},{"data":{"id":"bxt7u2ytjg80","created":1571459314683,"text":"百面机器学习","image":"https://kityminder-img.gz.bcebos.com/58ec3b64e87b007a93fdd6491a3418d34fde37ea","imageTitle":"","imageSize":{"width":147,"height":200}},"children":[]}]},{"data":{"id":"bym6w4b7yr40","created":1574401891972,"text":"Robot"},"children":[{"data":{"id":"bym6w6h5clk0","created":1574401896684,"text":"ROS_Robot_Programming","image":"https://kityminder-img.gz.bcebos.com/1d7da4981e34d5880256edef7d8f6a1f912bef27","imageTitle":"","imageSize":{"width":156,"height":200}},"children":[]}]}]},"template":"default","theme":"snow-compact","version":"1.4.43"}
</div>

<script type="text/javascript" src="https://unpkg.com/kity"></script>
<script type="text/javascript" src="https://unpkg.com/kityminder-core"></script>
<script type="text/javascript" src="https://unpkg.com/jquery"></script>

<script type="text/javascript">
        // 创建 km 实例
        /* global kityminder */
        var km = new kityminder.Minder();
        km.setup('.minder-view');
        km.disable();
        km.execCommand('hand');
        $(".km-receiver").remove()
</script>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/note/book-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/01/note/book-list/" class="post-title-link" itemprop="url">book list</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-01T00:00:00+08:00">2019-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index">
                    <span itemprop="name">note</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="minder-view" minder-data-type="json" style="width:100%; height:10000px;">
{"root":{"data":{"id":"134b381888bd","created":1566956099,"text":"书单"},"children":[{"data":{"id":"bwkvl51dr2g0","created":1566956122502,"text":"C/C++"},"children":[{"data":{"id":"bwkvrtb4c9s0","created":1566956645518,"text":"C Primer Plus","image":"http://kityminder-img.gz.bcebos.com/fe3b13e9b49bd6afe72e5b7c76bbe3cc41b66719","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkvrxgay480","created":1566956654539,"text":"C++ Primer Plus","image":"http://kityminder-img.gz.bcebos.com/3c39e5b69f99e4963d890689f541ea2370bda229","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bxu3ligws2w0","created":1571548918668,"text":"c++标准库","image":"https://kityminder-img.gz.bcebos.com/f2cb2ce914b97a3e74c401caf80f298db493a005","imageTitle":"","imageSize":{"width":173,"height":200}},"children":[]},{"data":{"id":"bxu3lh30sw80","created":1571548915652,"text":"STL源码剖析","image":"https://kityminder-img.gz.bcebos.com/12608ff6e1527b008e43a7d029d1630aa7c16f77","imageTitle":"","imageSize":{"width":160,"height":200}},"children":[]},{"data":{"id":"bxu3ikunye80","created":1571548688761,"text":"Effective C++","image":"https://kityminder-img.gz.bcebos.com/96dc76bf2f07e03d85a8f8640976d7a4543a292e","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bxu3an0clao0","created":1571548066545,"text":"More Effective C++","image":"https://kityminder-img.gz.bcebos.com/a7adaf31100ed712b4d53589189e40122f4c0e3b","imageTitle":"","imageSize":{"width":161,"height":200}},"children":[]},{"data":{"id":"bxu3dcm48ww0","created":1571548279009,"text":"Effective STL","image":"https://kityminder-img.gz.bcebos.com/7b3330ac09e2f25dd7cceac20a3953185b416dc1","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvl8wkzb40","created":1566956130919,"text":"代码"},"children":[{"data":{"id":"bwkvs3r9xnc0","created":1566956668263,"text":"重构 改善既有代码的设计 (第2版)","image":"http://kityminder-img.gz.bcebos.com/e8cac985c0d2e28a44e20d1eba39e42d188ebd25","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bxbid19rhd6o","created":1569660931789,"text":"图解设计模式","image":"http://kityminder-img.gz.bcebos.com/81b9215dce3160b4a24a2a0072321d89c7bf5692","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkvs6x5k280","created":1566956675149,"text":"领域专用语言实战","image":"http://kityminder-img.gz.bcebos.com/2ffbcc95493b60ebe826789901b359137e244579","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvs9x1ycg0","created":1566956681673,"text":"架构整洁之道","image":"http://kityminder-img.gz.bcebos.com/f5757144f7807f19b68bafffa57da26f93e7e780","imageTitle":"","imageSize":{"width":151,"height":200}},"children":[]},{"data":{"id":"bxqt8xo0tzk0","created":1571215042047,"text":"编程珠玑","image":"https://kityminder-img.gz.bcebos.com/1299338e48524484cb7088b6016ab43c95434bf6","imageTitle":"","imageSize":{"width":147,"height":200}},"children":[]}]},{"data":{"id":"bwkvle1arz40","created":1566956142088,"text":"Java","expandState":"expand"},"children":[{"data":{"id":"bwkvmbwcn5c0","created":1566956215799,"text":"Java基础","expandState":"expand"},"children":[{"data":{"id":"bwkvscyv1zc0","created":1566956688313,"text":"Java 8编程参考官方教程(第9版)","image":"http://kityminder-img.gz.bcebos.com/3597d69f5d304174e857e7ebf01f84aece30c0a6","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvsi1a9ts0","created":1566956699343,"text":"Java 8实战","image":"http://kityminder-img.gz.bcebos.com/626e44e79c09530afd77bbcea9c5d9da068fa61b","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvsmi367c0","created":1566956709066,"text":"图解Java多线程设计模式","image":"http://kityminder-img.gz.bcebos.com/2ad3a7b13418846822da5f36b2ffc32dc8aef3c8","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkvt1divvk0","created":1566956741442,"text":"码农翻身","image":"http://kityminder-img.gz.bcebos.com/d74d3a9f8e68aa00c41073c80d026f24ac15e78c","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvt7iu97c0","created":1566956754824,"text":"Effective Java中文版（原书第3版）","image":"http://kityminder-img.gz.bcebos.com/14c5c3ef802df2d676754615021621242e063a32","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]}]},{"data":{"id":"bwkvme9xzk00","created":1566956220975,"text":"JVM"},"children":[{"data":{"id":"bwkvst045ww0","created":1566956723217,"text":"深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）","image":"http://kityminder-img.gz.bcebos.com/d5531736ca642d7e77626568a9a906fe8f6a637d","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]},{"data":{"id":"bwkvsw0jdo80","created":1566956729773,"text":"JVM G1源码分析和调优","image":"http://kityminder-img.gz.bcebos.com/4d2c8cbf47a934ecd895cb6b4cf6161b64b081e6","imageTitle":"","imageSize":{"width":155,"height":200}},"children":[]},{"data":{"id":"bwkvtapzq0o0","created":1566956761787,"text":"自己动手写Java虚拟机","image":"http://kityminder-img.gz.bcebos.com/0e08f58f39dd2398897bbc98dd54e6c7bf3ed46d","imageTitle":"","imageSize":{"width":133,"height":200}},"children":[]}]},{"data":{"id":"bwkvli75q3k0","created":1566956151149,"text":"Spring"},"children":[{"data":{"id":"bwkvtp4air40","created":1566956793127,"text":"Spring实战（第4版）","image":"http://kityminder-img.gz.bcebos.com/6848bcf18ec91e0f97b7264eb6c8cccb7bbfcc34","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtrd64680","created":1566956798017,"text":"Spring Boot实战","image":"http://kityminder-img.gz.bcebos.com/9641bef0ec2e185e6b76c6c26d4220fe6c312114","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtuoor5k0","created":1566956805244,"text":"Spring微服务实战","image":"http://kityminder-img.gz.bcebos.com/dfee4134feef3b89dd5a5d31b6d0c5207b5e6e2a","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtx90o9k0","created":1566956810827,"text":"Spring Data实战","image":"http://kityminder-img.gz.bcebos.com/271cd38418aafe495eaef59e53d454a459e870f8","imageTitle":"","imageSize":{"width":152,"height":200}},"children":[]},{"data":{"id":"bxbdg0oyra4g","created":1569647060075,"text":"Spring技术内幕：深入解析Spring架构与设计原理（第2版）","image":"http://kityminder-img.gz.bcebos.com/a99f89fa09433576d7cab3c7f39676b124bc9844","imageTitle":"","imageSize":{"width":148,"height":200}},"children":[]}]},{"data":{"id":"bwkvlr83sg80","created":1566956170798,"text":"分布式"},"children":[{"data":{"id":"bwkvu8bucnk0","created":1566956834942,"text":"深入理解Nginx：模块开发与架构解析（第2版）","image":"http://kityminder-img.gz.bcebos.com/9a95a05c87ee92907bbaf6160e972ab3d8324e17","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvuavjqr40","created":1566956840487,"text":"深入浅出Docker","image":"http://kityminder-img.gz.bcebos.com/f305241a55947b9343bbd2461f5ca70e709e6bad","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bxbdrlnbsa2o","created":1569647967694,"text":"自己动手写Docker","image":"http://kityminder-img.gz.bcebos.com/948420c68fad4b9a42fa6ec70b7b2e2957f1f3b0","imageTitle":"","imageSize":{"width":149,"height":200}},"children":[]},{"data":{"id":"bwkvudhc1js0","created":1566956846158,"text":"Spring Cloud微服务：入门、实战与进阶","image":"http://kityminder-img.gz.bcebos.com/eeceaaf4b8e2611d26e439e9ed3b3055fc5c1d4e","imageTitle":"","imageSize":{"width":133,"height":200}},"children":[]}]},{"data":{"id":"bwkvmwat62o0","created":1566956260209,"text":"其它"},"children":[{"data":{"id":"bwkvvezmc4o0","created":1566956927805,"text":"Mybatis技术内幕","image":"http://kityminder-img.gz.bcebos.com/2ecfae24d4e26c3e298ac36bf75ca65d24473d0d","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvtks3f4w0","created":1566956783682,"text":"Netty实战","image":"http://kityminder-img.gz.bcebos.com/9f0a42ad8735552cdb4588ce36bf1b3ab4abf002","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvvccqt4w0","created":1566956922068,"text":"OAuth 2实战","image":"http://kityminder-img.gz.bcebos.com/5a565ce1fa9558d3f04e60c9bdc44297d090cdfe","imageTitle":"","imageSize":{"width":155,"height":200}},"children":[]}]}]},{"data":{"id":"bwkvlo4q6g00","created":1566956164063,"text":"数据库"},"children":[{"data":{"id":"bwkvu04lkow0","created":1566956817090,"text":"MySQL技术内幕：InnoDB存储引擎（第2版）","image":"http://kityminder-img.gz.bcebos.com/c1b83527c009f8c89ee5a119ece0ed0ba6588f0a","imageTitle":"","imageSize":{"width":133,"height":200}},"children":[]},{"data":{"id":"bwkvu3fhhzc0","created":1566956824279,"text":"Effective Sql","image":"http://kityminder-img.gz.bcebos.com/2b1c918c9b55a35833549e0ac4e9e352f029520c","imageTitle":"","imageSize":{"width":156,"height":200}},"children":[]},{"data":{"id":"bwkvu56qpug0","created":1566956828103,"text":"Redis实战","image":"http://kityminder-img.gz.bcebos.com/80d8843d1e11bca2ff5aaa9841936f7df8faa0d9","imageTitle":"","imageSize":{"width":158,"height":200}},"children":[]}]},{"data":{"id":"bwkvlvgluls0","created":1566956180019,"text":"Python"},"children":[{"data":{"id":"bwkvugnt1pc0","created":1566956853080,"text":"Python并行编程参考手册","image":"http://kityminder-img.gz.bcebos.com/b9c1bf306b06837d1e1b6ae60d3d04fa913b0ce8","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]},{"data":{"id":"bwkvuibxhx40","created":1566956856715,"text":"Python高性能编程","image":"http://kityminder-img.gz.bcebos.com/68aa17db831e39d24121d0961dea22dc1894432f","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvukij5t40","created":1566956861468,"text":"Effective Python","image":"http://kityminder-img.gz.bcebos.com/4f7c939d73eeb118839ae3643aabe9f7b9baffca","imageTitle":"","imageSize":{"width":156,"height":200}},"children":[]},{"data":{"id":"bwkvumczc540","created":1566956865486,"text":"Python源码剖析","image":"http://kityminder-img.gz.bcebos.com/e62ed8c3a8e41523f175fb430b5d49c4dd4d160e","imageTitle":"","imageSize":{"width":158,"height":200}},"children":[]},{"data":{"id":"bwkvuoyw1v40","created":1566956871164,"text":"自己动手写Python虚拟机","image":"http://kityminder-img.gz.bcebos.com/78d5638962bcfad452ad8487fea19e6a656e6f79","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvm16cav40","created":1566956192459,"text":"go","expandState":"expand"},"children":[{"data":{"id":"bxboiht39uo0","created":1569678286267,"text":"Go语言实战","expandState":"expand","image":"http://kityminder-img.gz.bcebos.com/488f7db5c0d687c99239b5d41c01c7b594980b0f","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]}]},{"data":{"id":"bwkvmp53glk0","created":1566956244626,"text":"大数据"},"children":[{"data":{"id":"bwkvuu66y8w0","created":1566956882490,"text":"Hadoop实战","image":"http://kityminder-img.gz.bcebos.com/1f99855644b499ed27a78b98429a9663ccf7951c","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvuwn5cc00","created":1566956887869,"text":"Elasticsearch实战","image":"http://kityminder-img.gz.bcebos.com/4308493804727d9e3217f59abba36460cab09d7d","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvuydspww0","created":1566956891657,"text":"Kafka Streams实战","image":"http://kityminder-img.gz.bcebos.com/ec545deac44743e594cc04d0e5892f94bacb3f83","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwl14xbkl400","created":1566971778537,"text":"数据挖掘导论","image":"http://kityminder-img.gz.bcebos.com/c8f8d2fa4862a49124c272beaf816434e47d85d5","imageTitle":"","imageSize":{"width":149,"height":200}},"children":[]}]},{"data":{"id":"bwkvn7ojogw0","created":1566956284984,"text":"系统"},"children":[{"data":{"id":"bwkvvv05w8w0","created":1566956962666,"text":"鸟哥的Linux私房菜 基础学习篇 第四版","image":"http://kityminder-img.gz.bcebos.com/089b1c7443f53140799f38c67d58df069379e339","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvvx19oa00","created":1566956967087,"text":"Linux内核设计与实现(原书第3版)","image":"http://kityminder-img.gz.bcebos.com/f3ae4637c7735245a7092c84706259b66ebacecb","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvvyyvj1k0","created":1566956971295,"text":"Linux内核完全剖析——基于0.12内核","image":"http://kityminder-img.gz.bcebos.com/ff6dbd053a82f6625b994567d710954e68830716","imageTitle":"","imageSize":{"width":141,"height":200}},"children":[]},{"data":{"id":"bwkvw1k6n680","created":1566956976937,"text":"编译原理（第2版）","image":"http://kityminder-img.gz.bcebos.com/790f4f21df0a786b3e1aff511276907519be1f06","imageTitle":"","imageSize":{"width":149,"height":200}},"children":[]},{"data":{"id":"bwkvw3cammg0","created":1566956980814,"text":"自己动手写编译器、链接器","image":"http://kityminder-img.gz.bcebos.com/c879366e0436542ac110e6e494e6c56c81a821c5","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvw5etgpk0","created":1566956985320,"text":"自己动手构造编译系统","image":"http://kityminder-img.gz.bcebos.com/c6a368bf9b061eb1c6f8323c33f5ca1311acde7f","imageTitle":"","imageSize":{"width":152,"height":200}},"children":[]},{"data":{"id":"bwkvw9rzztk0","created":1566956994824,"text":"垃圾回收算法手册：自动内存管理的艺术","image":"http://kityminder-img.gz.bcebos.com/7dd5bb2905c67256d5ac2682d50a210152fcb721","imageTitle":"","imageSize":{"width":141,"height":200}},"children":[]},{"data":{"id":"bwkx8ygs7j40","created":1566960810046,"text":"操作系统 精髓与设计原理 ","image":"http://kityminder-img.gz.bcebos.com/725f016d7d2fb94e76e0d767823d7ee12f87b049","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkxe90y5vc0","created":1566961224853,"text":"计算机组成(第6版)","image":"http://kityminder-img.gz.bcebos.com/726c685d05c6ed58c9c3bf46ad44dace3a000aca","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkxfqmzv6w0","created":1566961341556,"text":"计算机网络(第6版)","image":"http://kityminder-img.gz.bcebos.com/57d5798a51745f0ccdbec72181ad0fb5fe0c0055","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]}]},{"data":{"id":"bwkvnwvycmo0","created":1566956339852,"text":"网络"},"children":[{"data":{"id":"bwkvwcis9000","created":1566957000797,"text":"图解HTTP","image":"http://kityminder-img.gz.bcebos.com/50874fc99ba25f44426534c1002e17ed63022775","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]},{"data":{"id":"bwkvwesvajs0","created":1566957005761,"text":"图解TCP/IP：第5版","image":"http://kityminder-img.gz.bcebos.com/665c74c1ddfa98c45a309d5ea046e60419844e54","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]}]},{"data":{"id":"bwkvnyvyw8o0","created":1566956344206,"text":"算法"},"children":[{"data":{"id":"bwkvwh36ho00","created":1566957010738,"text":"数据结构与算法分析：C语言描述","image":"http://kityminder-img.gz.bcebos.com/021b23779cd82851985e3347dc887011d1eb8df0","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwjecqjc0","created":1566957015767,"text":"算法导论","image":"http://kityminder-img.gz.bcebos.com/f250d3b4392617434509f7e7022b865d4f33c17c","imageTitle":"","imageSize":{"width":151,"height":200}},"children":[]},{"data":{"id":"bwkvwlgyya80","created":1566957020279,"text":"算法竞赛入门经典（第2版）","image":"http://kityminder-img.gz.bcebos.com/6867bf5cdedba9cdf832745b3d97d70b6e9e9ae4","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwmvvrw00","created":1566957023358,"text":"算法竞赛入门经典 训练指南","image":"http://kityminder-img.gz.bcebos.com/f095bab9c7f6ae27f54915ff7d8cc00700809eba","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwpdg4w80","created":1566957028773,"text":"算法图解","image":"http://kityminder-img.gz.bcebos.com/1424a93d83a888ab03a018d224d11c45c0a70554","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwqwi3080","created":1566957032102,"text":"漫画算法：小灰的算法之旅","image":"http://kityminder-img.gz.bcebos.com/5ca50dc902a819f7316a9dcaba64d461daca3ccf","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]}]},{"data":{"id":"bwkvo0h1iqo0","created":1566956347657,"text":"其它"},"children":[{"data":{"id":"bwkvvppaxx40","created":1566956951126,"text":"图解网站分析：让流量倍增的网站优化方法","image":"http://kityminder-img.gz.bcebos.com/f2d8630f683f26d101680271b47a8f79a016eaff","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvvs5lgr40","created":1566956956464,"text":"图解密码技术 第3版","image":"http://kityminder-img.gz.bcebos.com/6579f49d4eed3f89ec9965e681a935b99ca9b796","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]}]},{"data":{"id":"bwkvo1hk2pk0","created":1566956349865,"text":"机器学习"},"children":[{"data":{"id":"bwkvwubm7f40","created":1566957039546,"text":"机器学习","image":"http://kityminder-img.gz.bcebos.com/31877ff7126872f2f560b4c168e058a2d553ee99","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwvpirvk0","created":1566957042564,"text":"Python神经网络编程","image":"http://kityminder-img.gz.bcebos.com/d2211092ac9a0f99293af2f06474f22e0d6eaaa8","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwxnwv680","created":1566957046820,"text":"TensorFlow：实战Google深度学习框架（第2版）","image":"http://kityminder-img.gz.bcebos.com/1cdea519b73766fd2cb5870111a0ea48e2485744","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvwzwic140","created":1566957051693,"text":"深度学习框架PyTorch：入门与实践","image":"http://kityminder-img.gz.bcebos.com/7c284e0f06efa3aad2616a1b5943d71e4585f51a","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvx1alc140","created":1566957054722,"text":"生成对抗网络入门指南","image":"http://kityminder-img.gz.bcebos.com/1290e73cfef8f998c36574adcd86234da9aaea03","imageTitle":"","imageSize":{"width":200,"height":200}},"children":[]},{"data":{"id":"bwkvx37npmw0","created":1566957058898,"text":"深度学习","image":"http://kityminder-img.gz.bcebos.com/407d622d6b1e4589fd439cea365046bad19f1dbd","imageTitle":"","imageSize":{"width":166,"height":200}},"children":[]},{"data":{"id":"bwkvx4jszao0","created":1566957061809,"text":"机器学习实战","image":"http://kityminder-img.gz.bcebos.com/388d614a84efad18829fb359a11ac62eb3d6f784","imageTitle":"","imageSize":{"width":159,"height":200}},"children":[]},{"data":{"id":"bwkvx6cvzzs0","created":1566957065744,"text":"统计学习方法（第2版）","image":"http://kityminder-img.gz.bcebos.com/c57b6c3a6642c028d824fa742ecb8f0f307dfa04","imageTitle":"","imageSize":{"width":153,"height":200}},"children":[]},{"data":{"id":"bwkvx889i8g0","created":1566957069818,"text":"动手学深度学习","image":"http://kityminder-img.gz.bcebos.com/0c2fd72eb38fd7c913e84107c430156dacb5eb3e","imageTitle":"","imageSize":{"width":142,"height":200}},"children":[]},{"data":{"id":"bwkvxo4njnc0","created":1566957104429,"text":"图解机器学习","image":"http://kityminder-img.gz.bcebos.com/eb23d19d9d0960b651291557a211eca3da4a183f","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]},{"data":{"id":"bwkvxqegx8o0","created":1566957109376,"text":"图解深度学习","image":"http://kityminder-img.gz.bcebos.com/58c63f24b5ac31b34318f373eeb63c8ede335eb6","imageTitle":"","imageSize":{"width":138,"height":200}},"children":[]},{"data":{"id":"bxt7u2ytjg80","created":1571459314683,"text":"百面机器学习","image":"https://kityminder-img.gz.bcebos.com/58ec3b64e87b007a93fdd6491a3418d34fde37ea","imageTitle":"","imageSize":{"width":147,"height":200}},"children":[]}]},{"data":{"id":"bym6w4b7yr40","created":1574401891972,"text":"Robot"},"children":[{"data":{"id":"bym6w6h5clk0","created":1574401896684,"text":"ROS_Robot_Programming","image":"https://kityminder-img.gz.bcebos.com/1d7da4981e34d5880256edef7d8f6a1f912bef27","imageTitle":"","imageSize":{"width":156,"height":200}},"children":[]}]},{"data":{"id":"bym6x9onasg0","created":1574401982032,"text":"数学"},"children":[]}]},"template":"default","theme":"snow-compact","version":"1.4.43"}
</div>

<script type="text/javascript" src="https://unpkg.com/kity"></script>
<script type="text/javascript" src="https://unpkg.com/kityminder-core"></script>
<script type="text/javascript" src="https://unpkg.com/jquery"></script>

<script type="text/javascript">
        // 创建 km 实例
        /* global kityminder */
        var km = new kityminder.Minder();
        km.setup('.minder-view');
        km.disable();
        km.execCommand('hand');
        $(".km-receiver").remove()
</script>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/deep_learning/paper/paper-ImageNet-Classification-with-Deep-Convolutional-Neural-Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/deep_learning/paper/paper-ImageNet-Classification-with-Deep-Convolutional-Neural-Networks/" class="post-title-link" itemprop="url">[paper] ImageNet Classification with Deep Convolutional Neural Networks</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-07T00:00:00+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 15:41:49" itemprop="dateModified" datetime="2019-12-26T15:41:49+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/deep-learning/" itemprop="url" rel="index">
                    <span itemprop="name">deep learning</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>全连接的神经网络需要消耗大量计算资源。</li>
<li>全连接难以应用到较高分辨率的图片。</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/2019/04/07/deep_learning/paper/paper-ImageNet-Classification-with-Deep-Convolutional-Neural-Networks/2.png" alt="effect"></p>
<h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><ul>
<li>在ImageNet子集上，训练了一个最大的卷积神经网络用于ILSVRC-2010和ILSVRC-2012比赛，获得最好成绩。</li>
<li>写了高优化的GPU实现2D卷积操作。</li>
<li><strong>网络使用许多新的方法改善，并减少训练时间。</strong></li>
<li><strong>使用有效的技术防止过拟合。</strong></li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><img src="/2019/04/07/deep_learning/paper/paper-ImageNet-Classification-with-Deep-Convolutional-Neural-Networks/1.png" alt="net"></p>
<ul>
<li>5层卷积</li>
<li>3层全连接</li>
<li>卷积后每层使用1层最大化池化层</li>
<li>每层使用ReLU(Rectified Linear Units)激活</li>
<li>LRU处理第1层（后来的论文证明无用）</li>
</ul>
<blockquote>
<p>ps:这里的网络，是将训练拆分成2部分，在2个GPU上跑，在第3层又映射到一起，后又拆分。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>1.卷积，ReLU激活，池化。(5层)</li>
<li>2.全连接，ReLU激活，softmax分类。</li>
</ul>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ul>
<li>1.线性激活和非线性(ReLU Nonlinearity)</li>
<li><ul>
<li>非线性的$f(x)=\tanh (x)$或$f(x)=\left(1+e^{-x}\right)^{-1}$饱和后梯度下降变慢。</li>
</ul>
</li>
<li><ul>
<li>ReLU训练速度更快。</li>
</ul>
</li>
<li>2.多GPU训练(Training on Multiple GPUs)</li>
<li>3.局部响应归一化(Local Response Normalization) - (2015 VGG指出LRN没有提升)</li>
<li><ul>
<li>在通道的维度上做LRN。</li>
</ul>
</li>
<li>4.减少过拟合(Reducing Overfitting)</li>
<li><ul>
<li>数据增强(Data Augmentation)：将256x256图片从4个角和中间裁减，和改变图像亮度强度等，增加数据量。</li>
</ul>
</li>
<li><ul>
<li>Dropout：训练过程中，0.5概率抛弃神经元，测试时，使用全部神经元。</li>
</ul>
</li>
</ul>
<h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p>网络结构基本同AlexNet，增加了许多细节优化。</p>
<p>主要贡献在于让人们时隔几十年，又再次发掘卷积神经网络价值。</p>
<p>卷积过滤器训练的是什么？</p>
<p>(下图是卷积层1的参数可视化)<br><img src="/2019/04/07/deep_learning/paper/paper-ImageNet-Classification-with-Deep-Convolutional-Neural-Networks/3.png" alt="conv1 filter"></p>
<p>可以看出是，低层的卷积过滤器提取到的是许多轮廓特征。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li>可视化理解卷积网络论文：Visualizing and Understanding Convolutional Networks</li>
<li>卷积过滤器的可视化理解：<a href="https://zhuanlan.zhihu.com/p/56112920" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56112920</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/python/python-%E5%B9%B6%E8%A1%8C6-%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/29/python/python-%E5%B9%B6%E8%A1%8C6-%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-title-link" itemprop="url">[python 并行6] 分布式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-29 18:42:09" itemprop="dateCreated datePublished" datetime="2018-11-29T18:42:09+08:00">2018-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>分布式计算的基本理念是将工作划分为一个一个小任务，分发给多台设备处理，再汇总结果。在分布式计算中，网络中的机器必须要保持可用（延迟误差、意外宕机等等），需要一个持续监控架构</p>
<hr>
<h1 id="分布式多进程-2"><a href="#分布式多进程-2" class="headerlink" title="分布式多进程 2"></a>分布式多进程 <sup>2</sup></h1><p><code>multiprocessing</code>的子模块<code>managers</code>还支持把多进程分布在多台机器上，<code>managers</code>模块已经封装好了网络通信的细节</p>
<p><strong>实现方法</strong>：我们可以使用<code>managers</code>模块将<code>queue</code>队列通过网络暴露出去，让其它机器访问到这个队列，然后就可以通过它实现数据交换</p>
<p>示例：<br>服务器通过暴露queue到网络，放入数据到队列，让客户端取出数据处理，再放回结果<br>服务器代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task_master.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random, time, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送任务的队列:</span></span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"><span class="comment"># 接收结果的队列:</span></span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>, callable=<span class="keyword">lambda</span>: task_queue)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>, callable=<span class="keyword">lambda</span>: result_queue)</span><br><span class="line"><span class="comment"># 绑定端口5000, 设置验证码'abc':</span></span><br><span class="line">manager = QueueManager(address=(<span class="string">''</span>, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 启动Queue:</span></span><br><span class="line">manager.start()</span><br><span class="line"><span class="comment"># 获得通过网络访问的Queue对象:</span></span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"><span class="comment"># 放几个任务进去:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    print(<span class="string">'Put task %d...'</span> % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"><span class="comment"># 从result队列读取结果:</span></span><br><span class="line">print(<span class="string">'Try get results...'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r = result.get(timeout=<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'Result: %s'</span> % r)</span><br><span class="line"><span class="comment"># 关闭:</span></span><br><span class="line">manager.shutdown()</span><br><span class="line">print(<span class="string">'master exit.'</span>)</span><br></pre></td></tr></table></figure><br>客户端代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task_worker.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器，也就是运行task_master.py的机器:</span></span><br><span class="line">server_addr = <span class="string">'127.0.0.1'</span></span><br><span class="line">print(<span class="string">'Connect to server %s...'</span> % server_addr)</span><br><span class="line"><span class="comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span></span><br><span class="line">m = QueueManager(address=(server_addr, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 从网络连接:</span></span><br><span class="line">m.connect()</span><br><span class="line"><span class="comment"># 获取Queue的对象:</span></span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"><span class="comment"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = task.get(timeout=<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'run task %d * %d...'</span> % (n, n))</span><br><span class="line">        r = n*n</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result.put(r)</span><br><span class="line">    <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">        print(<span class="string">'task queue is empty.'</span>)</span><br><span class="line"><span class="comment"># 处理结束:</span></span><br><span class="line">print(<span class="string">'worker exit.'</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="分布式架构库"><a href="#分布式架构库" class="headerlink" title="分布式架构库"></a>分布式架构库</h1><p><del>这篇仅是简单的分布式的简单操作，更多详情，搜索以下的内容作为关键字</del></p>
<p>使用面向对象模式和远程调用模式实现分布式框架的库，如Celery、SCOOP、Pyro4、RPyC，还有使用MapReduce实现的PyCSP、Disco</p>
<p>Celery：是一个用于管理分布式任务的Python框架<br>SCOOP：（Scalable Concurrent Operations in Python）用于进行科学计算<br>Pyro4：（Python Remote Object）远程调用方法，类似于java中远程方法调用(RMI)的库，支持调用远程对象（属于不同进程，或不同机器上）的方法，就好像它是本地对象<br>PyCSP：是基于通信的顺序进程（communicating sequential processes，简称CSP）的一个Python模块，它是通过消息传递方式构建并发程序的一种编程范式，特点：进程间的消息交换、通过线程使用共享内存、通过通道完成信息交换<br>Disco：是一个基于谷歌推出的MapReduce框架的Python模块，支持在计算机集群中管理大规模分布式数据</p>
<hr>
<p>1.参考书籍：《Python并行编程手册》</p>
<p>2.分布式多进程: 这段代码完全参考：廖雪峰 -分布式进程 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431929340191970154d52b9d484b88a7b343708fcc60000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431929340191970154d52b9d484b88a7b343708fcc60000</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/29/python/python-%E5%B9%B6%E8%A1%8C5-GPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/29/python/python-%E5%B9%B6%E8%A1%8C5-GPU/" class="post-title-link" itemprop="url">[python 并行5] GPU</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-29 12:50:47" itemprop="dateCreated datePublished" datetime="2018-11-29T12:50:47+08:00">2018-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<ol>
<li>需要有支持CUDA的Nvidia显卡<br> linux查看显卡信息：lspci | grep -i vga<br> 使用nvidia显卡可以这样查看：lspci | grep -i nvidia<br> 上一个命令可以得到类似”<strong>03.00.0</strong>“的显卡代号，查看详细信息：lspic -v -s 03.00.0<br> 查看显卡使用情况（nvidia专用）：nvidia-smi<br> 持续周期性输出使用情况（1秒1次）：watch -n 1 nvidia-smi</li>
<li>需要安装pycuda（linux安装：apt install python3-pycuda）</li>
</ol>
</blockquote>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="1-底层操作"><a href="#1-底层操作" class="headerlink" title="1.底层操作"></a>1.底层操作</h2><blockquote>
<ol>
<li>准备工作: sudo apt install python3-pycuda</li>
<li>在cpu使用的内存中创建矩阵</li>
<li>将矩阵从cpu使用的内存移动到gpu的显存中</li>
<li>编辑c语言代码，让gpu计算</li>
<li>将矩阵从gpu显存移动到cpu使用的内存中</li>
</ol>
</blockquote>
<p><strong>内核与线程层级</strong>：<br>CUDA程序的一个最重要元素就是内核（kernel），它代表可以并行执行的代码<br>每个内核的执行均有叫做线程（thread）的计算单元完成，与cpu的线程不同，gpu线程更加轻量，上下文切换不会影响性能<br>为了确定运行一个内核所需的线程数机器逻辑组织形式，CUDA定义了一个二层结构。在最高一层，定义了所谓的区块网格（grid of blocks），这个网格代表了线程区块所在的二维结构，而这些线程区块则是三维的（简单来说，一个cuda结构包含多个blocks，每个blocks包含多个thread）（在下面还会对每个线程区块细分操作）</p>
<p>一个线程区块会被指派给一个流式多处理器(SM)，然后这些线程被进一步划分为被称为warp的线程组，其大小有GPU的架构决定<br>为了充分发挥SM本身的并发性，同一组内的线程必须执行相同的指令，否则会出现线程分歧（divergence of thread）</p>
<p>示例：<br>用gpu将矩阵每个元素x2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycuda.driver <span class="keyword">as</span> cuda</span><br><span class="line"><span class="keyword">import</span> pycuda.autoinit  <span class="comment"># init GPU</span></span><br><span class="line"><span class="keyword">from</span> pycuda.compiler <span class="keyword">import</span> SourceModule</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.cpu create matrix</span></span><br><span class="line">a = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)	<span class="comment"># matrix:m*n</span></span><br><span class="line">a = a.astype(np.float32)	<span class="comment"># nvidia only support float calculate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.move to gpu from cpu</span></span><br><span class="line">a_gpu = cuda.mem_alloc(a.nbytes)	<span class="comment"># alloc memory of gpu, this is 1 dim</span></span><br><span class="line">cuda.memcpy_htod(a_gpu, a)		<span class="comment"># copy cpu memory to gpu memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.gpu calculate</span></span><br><span class="line"><span class="comment"># create module of gpu calculate by c</span></span><br><span class="line">mod = SourceModule(<span class="string">'''</span></span><br><span class="line"><span class="string">	__global__ void doubleMatrix(float *a)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		int idx = threadIdx.x + threadIdx.y * 5;	// (x,y,z), gpu -&gt; sm -&gt; warp</span></span><br><span class="line"><span class="string">		a[idx] *= 2;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line">func = mod.get_function(<span class="string">'doubleMatrix'</span>)	<span class="comment"># get function from module</span></span><br><span class="line">func(a_gpu, block = (<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>))		<span class="comment"># set var and thread number from (x,y,z) orient to function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.move to cpu from gpu</span></span><br><span class="line">a_doubled = np.empty_like(a)		<span class="comment"># create memory of cpu</span></span><br><span class="line">cuda.memcpy_dtoh(a_doubled, a_gpu)	<span class="comment"># copy gpu memory to cpu memory</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'original matrix'</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'double matrix'</span>)</span><br><span class="line">print(a_doubled)</span><br></pre></td></tr></table></figure></p>
<p><strong>注1</strong>：<strong>import pycuda.autoinit</strong> 语句自动根据GPU可用性和数量选择要使用的GPU，这将创建一个接下来的代码运行中所需的GPU上下文（只需导入即可完成）</p>
<p><strong>注</strong>: astype(numpy.float32)：将矩阵中的项转换为单精度模式，因为许多Nvidia显卡只支持单精度</p>
<p><strong>注3</strong>：在调用gpu的c函数时，通过block参数设定，分配线程的方式，（5, 5, 1）是对应这gpu的(x, y, x)的分配<br>在c函数中，threadIdx是一个结构体，它有三个字段<code>x</code>、<code>y</code>、<code>z</code>，每个线程中的这个变量都不同（结合线程层级理解），故用此索引数组，由于动态分配的gpu内存是一维数组，所以需要在c函数内，使用<code>threadIdx.y</code>乘以矩阵每行的元素个数转换<br>更多详情：自行搜索cuda的线程区块划分</p>
<p><strong>注4</strong>：gpu执行的c函数中 __global__ 关键字表示该函数是一个内核函数，必须从主机上调用才能在gpu设备上生成线程层级<br><del>涉及到pycuda内存，为了最大限度地利用可用资源，在支持CUDA的GPU显卡中，有4类内存：<br><code>寄存器(registers)</code>：每个线程将被分配一个寄存器，每个线程只能访问自身的寄存器，即使同属于一个线程区块<br><code>共享存储器(shared memory)</code>：在共享存储器中，每个线程区块都有一个其内部线程共享的内存，这部分内存速度极快<br><code>常数存储器(constant memory)</code>：一个网格中的所有线程一直都可以访问这部分内存，但只能在读取时访问。常数存储器中的数据在应用持续期间一直存在<br><code>全局存储器(global memory)</code>，：所有网格中的线程（也包含所有内核）都可访问全局存储器</del><br>更多详情：自行搜索PyCUDA内存模型</p>
<h2 id="2-python封装控制"><a href="#2-python封装控制" class="headerlink" title="2.python封装控制"></a>2.python封装控制</h2><p>用gpuarray调用内核，它可以直接将数据保存在计算设备(gpu)中，并在该设备中进行计算</p>
<p>示例：<br>用gpu将矩阵每个元素x2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycuda.autoinit</span><br><span class="line"><span class="keyword">import</span> pycuda.gpuarray <span class="keyword">as</span> gpuarray</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">x_gpu = gpuarray.to_gpu(x)</span><br><span class="line"></span><br><span class="line">x_doubled = (<span class="number">2</span> * x_gpu).get()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'x:'</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(<span class="string">'x_doubled:'</span>)</span><br><span class="line">print(x_doubled)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>还有其它的库可以方便对cuda编程，如NumbaPro是一个Python编译器，提供了基于CUDA的API编程接口，可以编写CUDA持续，它专门设计用来执行与数组相关的计算任务，和广泛使用的numpy库类似<br>NumbaPro: 对GPU编程的库，提供许多的数值计算库，GPU加速库</p>
<hr>
<p>1.参考书籍：《Python并行编程手册》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/python/python-%E5%B9%B6%E8%A1%8C4-%E5%BC%82%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/python/python-%E5%B9%B6%E8%A1%8C4-%E5%BC%82%E6%AD%A5/" class="post-title-link" itemprop="url">[python 并行4] 异步</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 23:52:37" itemprop="dateCreated datePublished" datetime="2018-11-28T23:52:37+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍 2"></a>介绍 <sup>2</sup></h1><p>除了<code>线性</code>、<code>并行</code>执行模式外，还有<code>异步</code>模式，它与事件编程一样，十分重要<br>在并发的异步模式中，不同的任务在时间线上是相互交错的，而且一切都是在单一控制流（单线程）下进行的</p>
<hr>
<h1 id="1-asyncio-过时"><a href="#1-asyncio-过时" class="headerlink" title="1.asyncio (过时)"></a>1.asyncio (过时)</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-1-使用asyncio实现事件循环管理"><a href="#1-1-使用asyncio实现事件循环管理" class="headerlink" title="1.1 使用asyncio实现事件循环管理"></a>1.1 使用asyncio实现事件循环管理</h3><p>什么是事件循环？<br>在计算系统中，能够产生事件的实体被称为事件源（event source），而负责协商管理事件的实体被称为事件处理器（event handler）<br>它实现了管理计算代码中所有事件的功能：在程序执行期间事件循环不断周期反复，追踪某个数据内部发生的事件，将其纳入队列，如果主线程空闲则调用事件处理器一个一个地处理这些事件</p>
<p><strong>注</strong>：事件循环不能使用<code>@asyncio.coroutine</code>标为协程</p>
<p>示例1：<br>延迟3秒后执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    time.sleep(<span class="number">1</span>)   <span class="comment"># 使用run_forever()不能用ayncio.sleep()延时</span></span><br><span class="line">    loop.call_soon(B)</span><br><span class="line">    print(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'b'</span>)</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># loop.call_soon(A, 'a')</span></span><br><span class="line">loop.call_later(<span class="number">3.0</span>, A, <span class="string">'a'</span>)</span><br><span class="line">loop.run_forever()</span><br><span class="line">loop.close()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><del>输出：</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br><span class="line">b	</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><del>在A()中再利用loop调用其它函数B()时，A也并不停下来，实现协程效果</del></p>
</blockquote>
<h3 id="1-2使用asyncio实现协程"><a href="#1-2使用asyncio实现协程" class="headerlink" title="1.2使用asyncio实现协程"></a>1.2使用asyncio实现协程</h3><p>什么是协程？<br>当程序变得冗长复杂时，将其划分成子例程的方式会使处理变得更加便利，每个子例程完成一个特定的任务<br>子例程无法独立运行，只能在主程序的要求下才能运行，主程序负责协调子例程的使用，协程就是子例程的泛化。在协程中，可以暂停执行点，同时保持干预时的本地状态，便于后续继续执行<br>协程相互交错的控制组件就是事件循环，事件循环追踪全部的协程，并安排其执行时间</p>
<blockquote>
<p>协程的其它重要特点：</p>
<pre><code>1. 协程支持多个进入点，可以多次生成（yield）
2. 协程能够执行转移至任何其它协程
</code></pre><p>生成(yield)这个术语用于描述那些暂停并将控制流传递给另一个协程的协程，协程可以同时传递控制流和值</p>
</blockquote>
<p>示例2：<br>A()和B()类似并行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a - start'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'a - end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'b - start'</span>)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> C()</span><br><span class="line">    print(x)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">f'b :<span class="subst">&#123;result&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'c - start'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'c - end'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'this is C return'</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># loop.run_until_complete(A())   # 只执行一个</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(asyncio.wait([A(), B('d')]))  # 并发执行方法1</span></span><br><span class="line">tasks = [asyncio.Task(A()), asyncio.Task(B(<span class="string">'b - end'</span>))]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))            <span class="comment"># 并发执行方法2</span></span><br><span class="line">loop.close()</span><br><span class="line">print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类asyncio.Task(coroutine)用于调度协程的执行</span></span><br><span class="line"><span class="comment"># asyncio.wait(tasks)将等待给定协程执行完毕</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><del>输出：</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a - start</span><br><span class="line">b - start</span><br><span class="line">c - start</span><br><span class="line">a - end</span><br><span class="line">c - end</span><br><span class="line">b - end</span><br><span class="line">b :this is C return</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><del>分析：<code>asyncio.sleep()</code>期间，主线程并未等待，而是去执行<code>EventLoop</code>中可执行的<code>coroutine</code></del></p>
</blockquote>
<p><strong>注</strong>：<code>@asyncio.coroutine</code>把一个generator标记为<code>coroutine</code>类型，再把这个coroutine放到EventLoop中执行（实测，可以不@标记）</p>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>loop = <strong>get_event_loop</strong>() : 获得当前上下文的事件循环<br>如果close()关闭了后，重新打开需要以下操作：<br>loop = asyncio.<strong>new_event_loop</strong>() : 创建新的时间循环对象<br>asyncio.<strong>set_event_loop</strong>(loop) : 将当前上下文的时间循环设置为指定的循环</p>
<p>loop.<strong>call_soon</strong>(callback, <em>args) : 立即调用回调对象，参数<br>loop.<strong>call_later</strong>(delay, callback, </em>args) : 延时delay秒后，调用回调对象<br>loop.<strong>call_at</strong>(when, callback, *args) : 在指定的时间调用回调对象，（when是绝对时间，可以参考loop.time()设置）</p>
<p>loop.<strong>run_forever()</strong> : 一直执行，直到调用stop()<br>loop.<strong>run_until_complete</strong>(future) : 运行指定的协程函数（Future<sup>3</sup>）</p>
<p>loop.<strong>time</strong>() : 获取事件循环的内部时钟<br>loop.<strong>close</strong>() : 关闭事件循环<br>loop.<strong>is_running</strong>() : 是否运行中<br>loop.<strong>is_close</strong>() : 是否关闭</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>示例：<br>异步网络并行访问<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wget</span><span class="params">(host)</span>:</span></span><br><span class="line">    print(<span class="string">'wget %s...'</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">yield</span> <span class="keyword">from</span> connect</span><br><span class="line">    header = <span class="string">'GET / HTTP/1.0\r\nHost: %s\r\n\r\n'</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = <span class="keyword">yield</span> <span class="keyword">from</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b'\r\n'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'%s header &gt; %s'</span> % (host, line.decode(<span class="string">'utf-8'</span>).rstrip()))</span><br><span class="line">    <span class="comment"># Ignore the body, close the socket</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> [<span class="string">'www.baidu.com'</span>, <span class="string">'www.aliyun.com'</span>, <span class="string">'www.qq.com'</span>]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="2-async-await"><a href="#2-async-await" class="headerlink" title="2.async/await"></a>2.async/await</h1><h2 id="2-1-客户端使用"><a href="#2-1-客户端使用" class="headerlink" title="2.1 客户端使用"></a>2.1 客户端使用</h2><p>为了简化标识异步io，python3.5引入新语法<code>async</code>、<code>await</code><br>只需将2步替换：</p>
<ol>
<li><code>asyncio.coroutine</code> -&gt; <code>async</code></li>
<li><code>yield from</code> -&gt; <code>await</code></li>
</ol>
<p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [asyncio.Task(A())]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))            <span class="comment"># 并发执行方法2</span></span><br><span class="line">loop.close()</span><br><span class="line">print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><br>替换为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [asyncio.Task(A())]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br><span class="line">print(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-服务器端使用"><a href="#2-2-服务器端使用" class="headerlink" title="2.2 服务器端使用"></a>2.2 服务器端使用</h2><p><code>asyncio</code>可以实现单线程并发io操作，如果仅用于客户端，效果不大<br>可以用在服务器端，由于HTTP连接就是io操作，因此可以使用单线程+协程实现多用户的高并发</p>
<p><code>asyncio</code>实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架</p>
<p>示例：<br>启动一个web服务，通过浏览器访问localhost:8000<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">'&lt;h1&gt;Index&lt;/h1&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    text = <span class="string">'&lt;h1&gt;hello, %s!&lt;/h1&gt;'</span> % request.match_info[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(loop)</span>:</span></span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/'</span>, index)</span><br><span class="line">    app.router.add_route(<span class="string">'GET'</span>, <span class="string">'/hello/&#123;name&#125;'</span>, hello)</span><br><span class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">'127.0.0.1'</span>, <span class="number">8000</span>)</span><br><span class="line">    print(<span class="string">'Server started at http://127.0.0.1:8000...'</span>)</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure></p>
<hr>
<p>1.参考书籍: 参考书籍：《Python并行编程手册》</p>
<p>2.参考文章1: 这篇主要参考：廖雪峰 - asyncio：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000</a></p>
<p>3.Future: Future：是Asyncio的一个类，与concurrent.futures.Futures非常相似，Futures类代表一个还不可用的结果，它是对尚未完成的任务的抽象表示；Python 3.2引入concurrent.futures模块，支持管理并发编程任务，如进程池和线程池、非确定性执行流、多进程、线程同步（这个目前没看出有什么特别的，池化管理不是多线程和多进程库自带吗？<del>concurrent.futures.ProcessPoolExecutor</del>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/python/python-%E5%B9%B6%E8%A1%8C3-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/13/python/python-%E5%B9%B6%E8%A1%8C3-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">[python 并行3] 进程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-13 20:04:12" itemprop="dateCreated datePublished" datetime="2018-11-13T20:04:12+08:00">2018-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用 1"></a>基本使用 <sup>1</sup></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os		<span class="comment"># 获取pid用</span></span><br><span class="line"><span class="keyword">import</span> time		<span class="comment"># 延时用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">f'child process <span class="subst">&#123;name&#125;</span> pid: <span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line">	print(<span class="string">f'<span class="subst">&#123;name&#125;</span> finish'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	print(<span class="string">f'parent process <span class="subst">&#123;os.getpid()&#125;</span> is running'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 生成子进程</span></span><br><span class="line">	p1 = multiprocessing.Process(target = child_proc, args = (<span class="string">'child-1'</span>,))</span><br><span class="line">	p2 = multiprocessing.Process(target = child_proc, args = (<span class="string">'child-2'</span>,))</span><br><span class="line">	p1.start()</span><br><span class="line">	p2.start()</span><br><span class="line"></span><br><span class="line">	print(<span class="string">f'parent process <span class="subst">&#123;os.getpid()&#125;</span> is end'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent process 20114 is running</span><br><span class="line">parent process 20114 is end</span><br><span class="line">child process child-1 pid: 20115</span><br><span class="line">child process child-2 pid: 20116</span><br><span class="line">child-1 finish</span><br><span class="line">child-2 finish</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>注意!</strong> Python官方文档提到为何必须要使用<code>if __name__ = &#39;__main__&#39;</code>，由于该包的所有功能都需要将主模块导入到子模块中，但是IDLE无法将<code>__main__</code>模块导入子模块，所以只能在文件中编辑好程序执行<br><strong>更多</strong>：<a href="https://docs.python.org/3/library/multiprocessing.html?highlight=multiprocessing#module-multiprocessing" target="_blank" rel="noopener">multiprocessing — Process-based parallelism</a></p>
<hr>
<h1 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h1><p><strong>注</strong>：根据查看<code>multiprocessing</code>模块声明，第一行注释显示<code># Package analogous to &#39;threading.py&#39; but using processes</code>，可以发现进程的操作与线程相似 <em>（甚至多进程的模块直接就是线程模块改过来的）</em></p>
<p><strong>函数声明</strong>： class multiprocessing.<strong>Process</strong>(group=None, target=None, name=None, args=(), kwargs={}, <em>, daemon=None)
</em>（group: 官方预留的参数）<em><br>target: 子线程要执行的函数<br>name: 给子线程命名<br>args: 传递参数到要执行的函数中 </em>（类型为元组）*<br>daemon: 将线程设置为后台线程 <sup>2</sup></p>
<blockquote>
<p>Thread类包含的方法：</p>
<ul>
<li><strong>start</strong>(): 开始进程，它会安排在单独的控制进程中使该对象的<code>run()</code>方法被调用 <em>(invoked)</em>  <em>（如果多次调用，会发生错误<code>AssertionError</code>）</em></li>
<li><strong>run</strong>(): 你可以在子类中重写这个方法，标准的<code>run()</code>方法会在构造器传递了<code>target</code>参数后调用它</li>
<li><strong>join</strong>(timeout=None): 阻塞当前进程，直到等待调用了<code>join()</code>的进程结束，或到达设置的超时<code>timeout</code>的参数为止</li>
<li><strong>name</strong>: 进程名</li>
<li><strong>is_alive</strong>(): 判断进程是否在运行</li>
<li><strong>daemon</strong>: 是否为后台进程的属性值</li>
<li><strong>pid</strong>: 返回进程的id</li>
<li><strong>terminate</strong>(): 结束进程<br><em>（在Unix上，使用<code>SIGTERM</code>信号量完成；在windows上使用TerminateProcess()）</em><br><em>（请注意，不会执行退出处理程序和最后的子句等。请注意，进程的后代进程不会被终止 - 它们将简单地变成孤立的。）</em><br><em>（注：如果在关联进程使用管道或队列时使用此方法，则管道或队列可能会损坏，并可能被其他进程无法使用。 类似地，如果进程已获得锁或信号量等，则终止它可能导致其他进程死锁。）</em></li>
<li><strong>kill</strong>(): 杀掉进程，与terminate()相同，但在Unix中使用<code>SIGKILL</code>信号量</li>
<li><strong>close</strong>(): 关闭进程对象，释放所有与之相关的资源。如果是还在运行，会raised错误<code>ValueError</code>，第一次调用会返回成功，其它调用会raise错误<code>ValueError</code></li>
<li><strong>exitcode</strong>: 子进程的退出码。如果不是被terminate终止的，将会是<code>None</code>；如果被信号量<code>N</code>终止的，将会返回-N</li>
<li><strong>authkey</strong>: 进程的身份钥匙（1字节字符串）。当<code>multipriocessing</code>在主进程中被初始化时，会使用<code>os.urandom()</code>标记一个随机字符串。当一个进程对象被创建时，它将会从父进程继承这个身份钥匙，虽然它可能会被改为其它字节字符串</li>
<li><strong>sentinel</strong>: （哨兵）当进程结束时，一个数值的系统对象处理将变为<code>ready</code>。如果你想立即要等待几个事件，你能用这个值使用<code>multiprocessing.connection.wait()</code>，否则调用<code>join()</code>更简单。</li>
</ul>
</blockquote>
<hr>
<h1 id="Pool进程池"><a href="#Pool进程池" class="headerlink" title="Pool进程池"></a>Pool进程池</h1><p>如果进程太多，超过了CPU核数，会导致进程之间的来回切换，影响性能。可以通过创建进程池，把进程加入到里面，如果池中进程没满，就会创建一个进程来执行请求；如果池中进程达到规定的最大值，那么请求会等待<br><strong>函数声明</strong>： class multiprocessing.pool.<strong>Pool</strong>([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])<br>processes: 指定池中进程数量，如果不指定，则为<code>None</code>，默认就会使用<code>os.cpu_count()</code><br>initializer: 如果不是<code>None</code>，每个进程在开始时都会调用<code>initializer(*initargs)</code><br>maxtasksperchild: 工作进程在退出和替换新的工作进程之前，可以完成的任务数量，以释放资源。默认为<code>None</code>，表示工作进程和这个池的生存时间一样长<br>context: 用来指定工作进程的上下文</p>
<p>下面有2种方法添加进程到进程池中，分别是<code>apply_async</code>和<code>apply</code></p>
<h2 id="apply-async"><a href="#apply-async" class="headerlink" title="apply_async"></a>apply_async</h2><p><code>apply_async()</code>用来同步执行进程，允许多个进程同时进入池；是异步非阻塞的<br><strong>函数声明</strong>:  apply_async(func[, args[, kwds[, callback[, error_callback]]]])<br>callback: 如果指定了回调，那么它应该是一个可调用的，它接受一个参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time		<span class="comment"># 延时用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(index)</span>:</span></span><br><span class="line">	print(<span class="string">f'<span class="subst">&#123;index&#125;</span> process is running'</span>)</span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line">	print(<span class="string">f'<span class="subst">&#123;index&#125;</span> process is end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	print(<span class="string">f'all process start'</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 生成进程池</span></span><br><span class="line">	p = multiprocessing.Pool()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		p.apply_async(func = child_proc, args = (i,))</span><br><span class="line">	p.close()</span><br><span class="line">	p.join()	<span class="comment"># 注! 如果不执行此句，将会直接退出主进程</span></span><br><span class="line"></span><br><span class="line">	print(<span class="string">f'all process done!'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">all process start</span><br><span class="line">0 process is running</span><br><span class="line">1 process is running</span><br><span class="line">2 process is running</span><br><span class="line">3 process is running</span><br><span class="line">4 process is running</span><br><span class="line">0 process is end</span><br><span class="line">3 process is end</span><br><span class="line">2 process is end</span><br><span class="line">4 process is end</span><br><span class="line">1 process is end</span><br><span class="line">all process done!</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><code>apply()</code>: 只允许一个进程进入池，在一个进程结束后，另一个才能进入；是阻塞的<br><strong>函数声明</strong>:   apply(func[, args[, kwds]])<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.apply(func = child_proc, args = (i,))	<span class="comment"># 将上面代码中的apply_async换成apply即可</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">all process start</span><br><span class="line">0 process is running</span><br><span class="line">0 process is end</span><br><span class="line">1 process is running</span><br><span class="line">1 process is end</span><br><span class="line">2 process is running</span><br><span class="line">2 process is end</span><br><span class="line">3 process is running</span><br><span class="line">3 process is end</span><br><span class="line">4 process is running</span><br><span class="line">4 process is end</span><br><span class="line">all process done!</span><br></pre></td></tr></table></figure><br><del>分析：对比apply_async和apply的输出，可以发现，apply_async是同步执行的，而apply是一个一个进入池中执行的</del></p>
</blockquote>
<hr>
<h1 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h1><p><a href="https://blog.csdn.net/lechunluo3/article/details/79005910" target="_blank" rel="noopener">参考：Python多进程编程-进程间共享数据</a><br><em>（<code>Pipe</code>、<code>Queue</code>都有一定的数据共享功能，但他们会阻塞进程）</em><br><code>Queue</code>：采用共享队列的内存的方式共享数据<br><strong>注意</strong>：存在<code>queue.Queue</code>、<code>multiprocessing.Queue</code>两种队列<br>queue.Queue：是进程内非阻塞队列，各进程私有<br>multiprocessing.Queue：是跨进程通信队列，各个子进程共有</p>
<p><strong>共享内存</strong>：使用multiprocessing的<code>Value</code>、<code>Array</code>类，实现共享内存的方式共享数据<br><strong>共享进程</strong>：使用multiprocessing的<code>Manager</code>类，实现共享进程的方式共享数据</p>
<h2 id="获取返回值（仅主进程获有数据）"><a href="#获取返回值（仅主进程获有数据）" class="headerlink" title="获取返回值（仅主进程获有数据）"></a>获取返回值（仅主进程获有数据）</h2><p>针对进程池实现的方式，可以直接通过获取进程对象的返回值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(x, y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># 生成进程池</span></span><br><span class="line">	p = multiprocessing.Pool()</span><br><span class="line">	z = p.apply(func = child_proc, args = (<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	print(z)</span><br></pre></td></tr></table></figure></p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>使用multiprocessing的<code>Queue</code>类，实现进程之间的数据共享<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(queue)</span>:</span></span><br><span class="line">	num = queue.get()</span><br><span class="line">	num += <span class="number">10</span></span><br><span class="line">	queue.put(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># 创建共享数据</span></span><br><span class="line">	queue = Queue()</span><br><span class="line">	queue.put(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建进程</span></span><br><span class="line">	p1 = Process(target = child_proc, args = (queue,))</span><br><span class="line">	p2 = Process(target = child_proc, args = (queue,))</span><br><span class="line">	p1.start()</span><br><span class="line">	p2.start()</span><br><span class="line">	p1.join()</span><br><span class="line">	p2.join()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 打印结果</span></span><br><span class="line">	print(queue.get())</span><br></pre></td></tr></table></figure></p>
<h2 id="Value、Array"><a href="#Value、Array" class="headerlink" title="Value、Array"></a>Value、Array</h2><p>共享内存有2个结构 - <code>Value</code>、<code>Array</code>，它们内部都实现了锁机制，因此是多进程安全的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(num, li)</span>:</span></span><br><span class="line">	num.value += <span class="number">100</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</span><br><span class="line">		li[i] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># 创建共享数据</span></span><br><span class="line">	num = Value(<span class="string">'d'</span>, <span class="number">0.0</span>)</span><br><span class="line">	li = Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建进程</span></span><br><span class="line">	p1 = Process(target = child_proc, args = (num, li))</span><br><span class="line">	p2 = Process(target = child_proc, args = (num, li))</span><br><span class="line">	p1.start()</span><br><span class="line">	p2.start()</span><br><span class="line">	p1.join()</span><br><span class="line">	p2.join()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 打印结果</span></span><br><span class="line">	print(num.value)</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> li:</span><br><span class="line">		print(x)</span><br></pre></td></tr></table></figure></p>
<p><strong>附</strong>：<code>Value</code>、<code>Array</code>都需要设置其中存放值的类型。d：double；i：int；c：char等<br><strong>详细</strong>：转到multiprocessing.<strong>sharedctypes</strong>可以查看到各种类型的字符串定义</p>
<h2 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h2><p><em>（上面的共享内存通过Value和Array结构实现，这些值在主进程中管理，很分散）</em><br>Manager通过共享内存来实现共享数据，支持的数据类型很多<br><strong>详细</strong>：<a href="https://docs.python.org/3/library/multiprocessing.html?highlight=managers#module-multiprocessing.managers" target="_blank" rel="noopener">multiprocessing.managers</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_proc</span><span class="params">(dict1, list1)</span>:</span></span><br><span class="line">	dict1[<span class="string">'yourname'</span>] += <span class="string">' snow'</span></span><br><span class="line">	list1[<span class="number">3</span>] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主进程，必须在主模块中执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># 创建共享数据</span></span><br><span class="line">	manager = Manager()</span><br><span class="line">	dict1 = manager.dict()</span><br><span class="line">	list1 = manager.list(range(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">	dict1[<span class="string">'yourname'</span>] = <span class="string">'youmux'</span></span><br><span class="line">	list1[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建进程</span></span><br><span class="line">	p1 = Process(target = child_proc, args = (dict1, list1))</span><br><span class="line">	p2 = Process(target = child_proc, args = (dict1, list1))</span><br><span class="line">	p1.start()</span><br><span class="line">	p2.start()</span><br><span class="line">	p1.join()</span><br><span class="line">	p2.join()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 打印结果</span></span><br><span class="line">	print(dict1[<span class="string">'yourname'</span>])</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> list1:</span><br><span class="line">		print(x)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>1.参考书籍: 参考书籍：《Python并行编程手册》</p>
<p>2.后台线程: 后台线程在主线程停止后就直接停止运行。他们资源（如打开的文件，数据库事务等）可能不会被正确的释放。如果你想要你的线程优美的停止，让他们不要变为后台和使用一个合适的信号机制如事件<code>Event</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/07/python/python-%E5%B9%B6%E8%A1%8C2-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/07/python/python-%E5%B9%B6%E8%A1%8C2-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">[python 并行2] 线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-07 23:29:48" itemprop="dateCreated datePublished" datetime="2018-10-07T23:29:48+08:00">2018-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>python线程使用的两个模块为： <del><code>_thread</code>  <em>(不推荐再使用)</em></del>、 <code>threading</code><br> <em>（查看threading的源码可以发现，threading实际是对_thread进一步的封装，官方将其称为 </em>Low-level threading API<em>，下面简单尝试使用_thread）</em></p>
<p><del>调用start_new_thread()函数生成新线程<br><strong>函数声明</strong>：_thread.start_new_thread(function, args[, kwargs])<br>function: 子线程所执行的函数<br>args: 传递的参数，参数类型必须是<strong>元组</strong><br>kwargs:可选参数</del></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(t_name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(t_name, <span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line">_thread.start_new_thread(func, (<span class="string">'my_thread_1'</span>,))    <span class="comment"># 传递的参数必须是元组类型</span></span><br><span class="line">print(<span class="string">'main thread end'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)   <span class="comment"># 暂停一下等待子线程，避免主线程结束后直接退出，看不到子线程的输出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main thread end</span><br><span class="line">my_thread_1 end</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>更多</strong>：<a href="https://docs.python.org/3/library/_thread.html" target="_blank" rel="noopener">_thread — Low-level threading API</a></p>
<h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><p><strong>需要 import threading</strong><br>threading模块提供了比_thread模块更加高级别的方法，如下：</p>
<blockquote>
<ul>
<li>threading.<strong>active_count</strong>(): 返回当前运行的线程数量</li>
<li>threading.<strong>current_thread</strong>(): 返回当前运行的线程对象</li>
<li>threading.<strong>get_ident</strong>(): 返回当前运行的线程标识码</li>
<li>threading.<strong>enumerate</strong>(): 获取运作着的线程对象的列表（包含设置了daemon属性的后台线程）</li>
<li>threading.<strong>main_thread</strong>(): 获取主线程对象</li>
</ul>
</blockquote>
<p>threading模块包含Thread类来处理线程<br><strong>函数声明</strong>：class threading.<strong>Thread</strong>(group=None, target=None, name=None, args=(), kwargs={}, <em>, daemon=None)
</em>（group: 官方预留的参数）<em><br>target: 子线程要执行的函数<br>name: 给子线程命名<br>args: 传递参数到要执行的函数中 </em>（类型为元组）*<br>daemon: 将线程设置为后台线程 <sup>1</sup></p>
<blockquote>
<p>Thread类包含的方法：</p>
<ul>
<li><strong>start</strong>(): 开始线程，它会安排在单独的控制线程中使该对象的<code>run()</code>方法被调用 <em>(invoked)</em> <sup>2</sup> <em>（如果多次调用，会raise <code>RuntimeError</code>）</em></li>
<li><strong>run</strong>(): 你可以在子类中重写这个方法，标准的<code>run()</code>方法会在构造器传递了<code>target</code>参数后调用它</li>
<li><strong>join</strong>(timeout=None): 阻塞当前线程，直到等待调用了<code>join()</code>的线程结束，或到达设置的超时<code>timeout</code>的参数为止 <em>（如果尝试加入当前线程 <sup>3</sup>，因为会发生死锁，<code>join()</code>会raise <code>RuntimeError</code>。在线程启动前调用<code>join()</code>也会报相同的错误）</em></li>
<li><strong>name</strong>: 线程名</li>
<li><strong>ident</strong>: 线程标识码 <em>（如果线程未<code>start()</code>，则为<code>None</code>。实测线程结束后，ident值还存在）</em></li>
<li><strong>is_alive</strong>(): 判断线程是否在运行</li>
<li><strong>daemon</strong>: 是否为后台线程的属性值</li>
<li><strong>isDaemon</strong>(): 判断是否为后台线程</li>
</ul>
</blockquote>
<p><strong>更多</strong>：<a href="https://docs.python.org/3/library/threading.html" target="_blank" rel="noopener">threading — Thread-based parallelism</a></p>
<h3 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h3><p>使用threading.<strong>Thread</strong>类实例化对象，再调用<code>start()</code>方法运行</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(threading.current_thread().name, <span class="string">' start'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.current_thread().name, <span class="string">' end'</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func)   <span class="comment"># 创建线程</span></span><br><span class="line">t2 = threading.Thread(target=func)</span><br><span class="line"></span><br><span class="line">t1.start()   <span class="comment"># 开始线程</span></span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># t1.join()    # 等待该线程结束后，再往下执行</span></span><br><span class="line"><span class="comment"># t2.join()</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'main thread end'</span>)    <span class="comment"># 使用threading模块Thread类的线程，程序需要等待全部线程执行完后才退出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1  start</span><br><span class="line">Thread-2  start</span><br><span class="line">main thread end</span><br><span class="line">Thread-1  end</span><br><span class="line">Thread-2  end</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="继承类的形式"><a href="#继承类的形式" class="headerlink" title="继承类的形式"></a>继承类的形式</h3><p>通过继承threading.Thread类，可以重写<code>run()</code>方法，再实例化该类，调用<code>start()</code>方法运行<br><em>（继承Thread类，并不是非要重写<code>run()</code>）</em></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name + <span class="string">' start'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(self.name + <span class="string">' end'</span>)</span><br><span class="line"></span><br><span class="line">t1 = MyThread(<span class="string">'thread1'</span>)</span><br><span class="line">t2 = MyThread(<span class="string">'thread2'</span>)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># t1.join()</span></span><br><span class="line"><span class="comment"># t2.join()</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'main thread end'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 start</span><br><span class="line">thread2 start</span><br><span class="line">main thread end</span><br><span class="line">thread1 end</span><br><span class="line">thread2 end</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当属于并发线程的多个操作尝试访问共享内存，并且至少有一个操作能修改数据的状态时，这时如果没有恰当的同步机制，可能会发生意外情况或bug。使用<code>锁</code>可以解决此问题。<br>当一个线程想要访问共享内存的某一部分区域时，它必须再使用前获取到该部分的锁。并在操作完后，要释放掉之前获取到的锁。</p>
<p><strong>注意!</strong> 要避免<code>死锁</code> <sup>4</sup>的情况发生</p>
<h2 id="使用Lock实现线程同步"><a href="#使用Lock实现线程同步" class="headerlink" title="使用Lock实现线程同步"></a>使用Lock实现线程同步</h2><p>使用threading.Lock()实例化Lock锁对象<br>在共享资源操作的部分，调用Lock的方法<code>acquire()</code>获取锁<br>结束操作后，调用Lock的方法<code>release()</code>释放锁，以便于其它线程使用该资源</p>
<p><em>（函数声明：<br><strong>acquire</strong>(blocking=True, timeout=-1)<br>获取锁，并阻塞其它线程访问这部分资源<br>blocking[ <sup>5</sup>: 设置为False的线程不会被阻塞 </em>（并且<code>timeout</code>设置为默认值-1时，失去同步效果。设置为非-1值时，被设置为True的线程阻塞，则False立即返回。这2种情况都会提示错误信息）<em><br>timeout: 设置等待的超时值，-1为无限等待，超时后无视阻塞<br>返回值为<code>True</code>成功获取锁定，<code>False</code>反之（例如超时到期）<br><strong>release</strong>()<br>在未锁的资源上调用释放锁方法，会引发<code>RuntimeError</code>）</em></p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()     <span class="comment"># 创建Lock锁</span></span><br><span class="line">num = <span class="number">0</span>     <span class="comment"># 累加这个变量，观察不同步的情况出现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 获取锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):    <span class="comment"># 如果未出现不同步，是由于运算太快，加大循环值</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t2 = threading.Thread(target=func)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">有锁情况下，输出：</span><br><span class="line">2000000</span><br><span class="line"></span><br><span class="line">无锁情况下，不同步，输出：</span><br><span class="line">第一次输出：</span><br><span class="line">1253312</span><br><span class="line">第二次输出：</span><br><span class="line">1227567</span><br><span class="line">第三次输出：</span><br><span class="line">1309097</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注!</strong> 书中并不提倡使用锁来解决，因为可能会导致死锁情况发生，也会对代码的可读性产生影响，调试困难</p>
<h2 id="使用RLock实现线程同步"><a href="#使用RLock实现线程同步" class="headerlink" title="使用RLock实现线程同步"></a>使用RLock实现线程同步</h2><p>可重入锁（reentrant lock）<br>操作方式同Lock锁</p>
<p><strong>与Lock的区别</strong>：RLock在 <strong>同一个线程中</strong>可以多次<code>acquire()</code>获取锁而不发生阻塞 <em>（这是为了解决一些特殊场景的使用）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部分代码</span></span><br><span class="line">lock = threading.RLock()     <span class="comment"># 创建RLock锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 获取锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure>
<p><strong>注意!</strong> acquire()需要成对使用</p>
<h2 id="使用信号量实现线程同步"><a href="#使用信号量实现线程同步" class="headerlink" title="使用信号量实现线程同步"></a>使用信号量实现线程同步</h2><p><strong>信号量</strong>的提出，首次用在操作系统中。它是一个操作系统管理的抽象数据类型，用于同步多个线程对共享资源与数据的访问<br><em>（本质上，信号量是由一个内部变量构成的，它标识出了对其所关联的资源的并发访问量）</em></p>
<p>使用threading.<strong>Semaphore</strong>()创建对象<br>在线程模块中，信号量的操作基于<code>acquire()</code>与<code>release()</code></p>
<p>当一个线程想使用一个资源，它需要调用<code>acquire()</code>，会判断信号量内部变量值_value，如果为0则阻塞线程，并且进行timeout超时处理，如果_value不为0，线程运行 <em>（由于信号量的初始值为非负数，故设计中不存在负数情况的代码）</em><br>当一个线程使用完一个资源后，它需要调用<code>release()</code>，该操作会增加信号量的内部变量值，并通知等待的线程<br><em>（ <strong>注!</strong> 书中的描述和threading模块的源码不符，重新按源码的理解写）</em></p>
<p><strong>注意!</strong> <code>acquire()</code>和<code>release()</code>并不需要放在某段代码的前后，来锁住某段资源</p>
<p><strong>示例：</strong></p>
<p><em>（由于书中给的示例代码，感觉很符合理解信号量的特点，这里也采用生产者和消费者的关系编写代码）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选参数为内部变量_value赋初值，默认为1</span></span><br><span class="line"><span class="comment"># 如果赋的值小于0，会raise ValueError异常</span></span><br><span class="line">sem = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> item</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    item = random.randint(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    print(<span class="string">'producer: produced'</span>, item)</span><br><span class="line">    sem.release()   <span class="comment"># 释放信号量，将内部_value加1，并通知其它等待的线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'consumer is waiting'</span>)</span><br><span class="line">    sem.acquire()   <span class="comment"># 获取信号量，值等于0则阻塞线程，否则内部_value减1，并继续运行</span></span><br><span class="line">    print(<span class="string">'consumer: sonsumed'</span>, item)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=producer)</span><br><span class="line">t2 = threading.Thread(target=consumer)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer is waiting</span><br><span class="line">producer: produced 295</span><br><span class="line">consumer: sonsumed  295</span><br></pre></td></tr></table></figure></p>
<p><em><del>分析：多执行几次，逻辑上可以发现消费者总需要等待生产者生产出产品后，才能消费</del></em></p>
</blockquote>
<p>可以看出信号量很适合这样的场景，下面可以测试，生产者可以多生产几个，消费者再消费</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import threading</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem = threading.Semaphore()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.acquire()    <span class="comment"># 获取初始化的信号量</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.release()    <span class="comment"># 信号量+1</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.release()    <span class="comment"># 信号量+1</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.release()    <span class="comment"># 信号量+1</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.acquire()    <span class="comment"># 信号量-1</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.acquire()    <span class="comment"># 信号量-1</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.acquire()    <span class="comment"># 信号量-1</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; sem.acquire()    <span class="comment"># 由于信号量=0</span></span></span><br><span class="line">    # 所以陷入了阻塞</span><br></pre></td></tr></table></figure>
<h2 id="使用条件实现线程同步"><a href="#使用条件实现线程同步" class="headerlink" title="使用条件实现线程同步"></a>使用条件实现线程同步</h2><p>使用threading.<strong>Condition</strong>()创建对象</p>
<p>查看Condition的源码，发现可以传入一个锁作为初始化参数。如果不传，默认会赋值<code>RLock</code>锁来进行后续的锁的操作 <em>（<code>acquire()</code>、<code>release()</code>）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Condition类的初始化部分源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lock=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            lock = RLock()</span><br><span class="line">        self._lock = lock</span><br><span class="line">        <span class="comment"># Export the lock's acquire() and release() methods</span></span><br><span class="line">        self.acquire = lock.acquire</span><br><span class="line">        self.release = lock.release</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<p><em>（下例还是使用生产者和消费者的关系编写示例代码，用items作为存储容器，以满了(10个)就不能再生产作为条件，以没了(0个)就不能再消费作为条件）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()   <span class="comment"># 创建条件</span></span><br><span class="line">items = []      <span class="comment"># 作为产品的存储容器，设达到10个为满了，就不能再生产了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> items</span><br><span class="line">    condition.acquire()     <span class="comment"># 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> len(items) == <span class="number">10</span>:</span><br><span class="line">        print(<span class="string">'producer: stop produce'</span>)</span><br><span class="line">        condition.wait()    <span class="comment"># 等待(items达到10，等待消费者消费)</span></span><br><span class="line">    items.append(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'producer: produced'</span>, len(items))</span><br><span class="line">    condition.notify()      <span class="comment"># 通知等待的线程</span></span><br><span class="line">    condition.release()     <span class="comment"># 释放锁</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> items</span><br><span class="line">    condition.acquire()     <span class="comment"># 获取锁</span></span><br><span class="line">    <span class="keyword">if</span> len(items) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'consumer: waiting'</span>)</span><br><span class="line">        condition.wait()    <span class="comment"># 等待(items为0，等待生产者生产)</span></span><br><span class="line">    items.pop()       <span class="comment"># 注! 注释掉这行，会发现，等待wait()在接收到通知notify()后，并没有再次判断条件，直接就接着运行了</span></span><br><span class="line">    print(<span class="string">'consumer: sonsumed'</span>, len(items))</span><br><span class="line">    condition.notify()      <span class="comment"># 通知等待的线程</span></span><br><span class="line">    condition.release()     <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># producer_loop()和consumer_loop()用来多次循环运行，为了达到items为0或10的情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        producer()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line">        consumer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=producer_loop)</span><br><span class="line">t2 = threading.Thread(target=consumer_loop)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">producer: produced 1</span><br><span class="line">producer: produced 2</span><br><span class="line">producer: produced 3</span><br><span class="line">consumer: sonsumed 2</span><br><span class="line">producer: produced 3</span><br><span class="line">producer: produced 4</span><br><span class="line">producer: produced 5</span><br><span class="line">producer: produced 6</span><br><span class="line">consumer: sonsumed 5</span><br><span class="line">producer: produced 6</span><br><span class="line">producer: produced 7</span><br><span class="line">producer: produced 8</span><br><span class="line">producer: produced 9</span><br><span class="line">consumer: sonsumed 8</span><br><span class="line">producer: produced 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">producer: stop produce</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">producer: produced 10</span><br><span class="line">consumer: sonsumed 9</span><br><span class="line">consumer: sonsumed 8</span><br><span class="line">consumer: sonsumed 7</span><br><span class="line">consumer: sonsumed 6</span><br><span class="line">consumer: sonsumed 5</span><br><span class="line">consumer: sonsumed 4</span><br><span class="line">consumer: sonsumed 3</span><br><span class="line">consumer: sonsumed 2</span><br><span class="line">consumer: sonsumed 1</span><br><span class="line">consumer: sonsumed 0</span><br></pre></td></tr></table></figure></p>
<p><em><del>分析：观察可以发现，生产者生产满了10个就会进入等待<code>wait()</code>，直到消费者通知<code>notify()</code></del><br><del>为了观察消费者消费到0个的情况，可以将生产者和消费者循环的等待时间做调整</del></em></p>
</blockquote>
<h2 id="使用事件实现线程同步"><a href="#使用事件实现线程同步" class="headerlink" title="使用事件实现线程同步"></a>使用事件实现线程同步</h2><p>查看Event类的源码，发现内部使用的是条件<code>Condition</code>类实现，并传入了<code>Lock</code>锁。事件通过对内部的<strong>标志_flag</strong>进行管理来实现线程同步<br>使用<code>set()</code>方法可以将标志设为True<br>使用<code>clear()</code>方法将其重置为False<br>使用<code>wait()</code>方法阻塞线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Event类的初始化源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cond = Condition(Lock())</span><br><span class="line">        self._flag = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>注意!</strong> 并不存在<code>set()</code>和<code>clear()</code>放在某段代码的前后，来锁住某段资源</p>
<p><strong>示例：</strong><br><em>（还是采用生产者和消费者的关系编写，生产者做完工作，调用<code>set()</code>设置<code>_flag</code>标志，并通知<code>wait()</code>等待的消费者线程运行；再使用<code>clear()</code>清除<code>_flag</code>标志，以便后面的消费者能正确的进入等待。这个过程类似于事件的触发）</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">event = threading.Event()   <span class="comment"># 创建事件</span></span><br><span class="line">items = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment"># 设置个初值，便于后面注释event.clear()后的测试(可以发现,消费者不等待了)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> items</span><br><span class="line">    print(<span class="string">'producer: start'</span>)</span><br><span class="line">    items.append(random.randint(<span class="number">0</span>,<span class="number">100</span>))</span><br><span class="line">    event.set()     <span class="comment"># 将内部标志_flag设为True,并通知所有等待的线程(类似于触发事件)</span></span><br><span class="line">    print(<span class="string">'producer: notify'</span>)</span><br><span class="line">    event.clear()   <span class="comment"># 将内部标志_flag设为False(只有清除了_flag,消费者下一次的wait()操作才会正常进入等待)(clear()操作也可以交给消费者调用，不过为了简化消费者的操作，让消费者只需要等待通知即可)</span></span><br><span class="line">    print(<span class="string">'producer: end'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> items</span><br><span class="line">    print(<span class="string">'consumer: waiting'</span>)</span><br><span class="line">    event.wait()    <span class="comment"># 等待(等待生产者通知,根据_flag标志判断是否进入等待)</span></span><br><span class="line">    print(<span class="string">'consumer:'</span>, items.pop())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># producer_loop()和consumer_loop()用来多次循环运行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        producer()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 消费者有wait()等待，就不用线程休眠了，以免错过生产者的set()通知</span></span><br><span class="line">        consumer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=producer_loop)</span><br><span class="line">t2 = threading.Thread(target=consumer_loop)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">consumer: waiting</span><br><span class="line">producer: start</span><br><span class="line">producer: notify</span><br><span class="line">consumer: 57</span><br><span class="line">consumer: waiting</span><br><span class="line">producer: end</span><br><span class="line">producer: start</span><br><span class="line">producer: notify</span><br><span class="line">consumer: 10</span><br><span class="line">producer: end</span><br><span class="line">consumer: waiting</span><br><span class="line">producer: start</span><br><span class="line">producer: notify</span><br><span class="line">consumer: 24</span><br><span class="line">producer: end</span><br><span class="line">consumer: waiting</span><br></pre></td></tr></table></figure></p>
<p><del>如果注释掉代码中的<code># event.clear()</code>一行，会出现如下输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">consumer: waiting</span><br><span class="line">producer: start</span><br><span class="line">producer: notify</span><br><span class="line">consumer: 19</span><br><span class="line">producer: end</span><br><span class="line">consumer: waiting</span><br><span class="line">consumer: 3</span><br><span class="line">consumer: waiting</span><br><span class="line">consumer: 2</span><br><span class="line">consumer: waiting</span><br><span class="line">consumer: 1</span><br><span class="line">consumer: waiting</span><br><span class="line">Exception in thread Thread-2:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\app\Python\Python37\lib\threading.py&quot;, line 917, in _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File &quot;D:\app\Python\Python37\lib\threading.py&quot;, line 865, in run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File &quot;g:&#x2F;tmp&#x2F;code.py&quot;, line 35, in consumer_loop</span><br><span class="line">    consumer()</span><br><span class="line">  File &quot;g:&#x2F;tmp&#x2F;code.py&quot;, line 24, in consumer</span><br><span class="line">    print(&#39;consumer:&#39;, items.pop())</span><br><span class="line">IndexError: pop from empty list</span><br></pre></td></tr></table></figure></p>
<p>producer: start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">producer: notify</span><br><span class="line">producer: end</span><br><span class="line">producer: start</span><br><span class="line">producer: notify</span><br><span class="line">producer: end</span><br></pre></td></tr></table></figure></p>
<p><em><del>分析：会发现，消费者没有等待(打印出的consumer: waiting，只是给自己的提示，实际没有等待)，直接进行了列表的<code>pop()</code>操作，直到后面列表为空再弹出时报错为止</del></em></p>
</blockquote>
<hr>
<h1 id="附：其它"><a href="#附：其它" class="headerlink" title="附：其它"></a>附：其它</h1><h2 id="使用with语句-6"><a href="#使用with语句-6" class="headerlink" title="使用with语句 6"></a>使用with语句 <sup>6</sup></h2><p><em>（由于没有理解部分，这一部分基本就是书中原文）</em></p>
<p><strong>with</strong>: 是Python 2.5中引入的。当有两个相关的操作需要对一个代码块承兑执行时，with语句的作用就彰显出来了。它可以再自动精确的分配或释放资源 <em>（因此也被称为上下文管理器）</em>。如线程模块中，使用到<code>acquire()</code>和<code>release()</code>方法的地方，都可以采用<code>with</code>语句块，如下：</p>
<blockquote>
<ul>
<li>Lock</li>
<li>RLock</li>
<li>条件</li>
<li>信号量 <em>（感觉这用了<code>with</code>就不太灵活了）</em></li>
</ul>
</blockquote>
<p><strong>示例：</strong><br><em>（会测试上述列表中的with操作）</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_with</span><span class="params">(statement)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> statement: <span class="comment"># 会自动进行acquire()和release()</span></span><br><span class="line">        print(<span class="string">'//todo1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_not_with</span><span class="params">(statement)</span>:</span></span><br><span class="line">    statement.acquire()</span><br><span class="line">    <span class="keyword">try</span>:    <span class="comment"># 为了避免出现异常，导致没有release()释放</span></span><br><span class="line">        print(<span class="string">'//todo2'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        statement.release()</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">rlock = threading.RLock()</span><br><span class="line">condition = threading.Condition()</span><br><span class="line">sem = threading.Semaphore(<span class="number">1</span>)    <span class="comment"># 采用with，需要初始至少有一个信号量值（因为需要先acquire()）</span></span><br><span class="line"></span><br><span class="line">li = [lock, rlock, condition, sem]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> statement <span class="keyword">in</span> li:</span><br><span class="line">    t1 = threading.Thread(target=func_with, args=(statement,))</span><br><span class="line">    t2 = threading.Thread(target=func_not_with, args=(statement,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></p>
<h2 id="使用队列实现线程通信"><a href="#使用队列实现线程通信" class="headerlink" title="使用队列实现线程通信"></a>使用队列实现线程通信</h2><p>虽然python线程模块提供了很多同步原语 <em>（<code>锁</code>、<code>信号量</code>、<code>条件</code>、<code>事件</code>）</em>，但有时候，在使用场景中，可能采用队列模块会是个最佳选择。它使得线程编程变得更加容易和安全</p>
<p>使用队列<code>Queue</code>的方式处理，尽管它不属于<code>threading</code>模块，但查看其源码，发现队列的功能实现有用到<code>threading</code>模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Queue的初始化源码</span><br><span class="line">    def __init__(self, maxsize&#x3D;0):</span><br><span class="line">        self.maxsize &#x3D; maxsize</span><br><span class="line">        self._init(maxsize)</span><br><span class="line"></span><br><span class="line">        # mutex must be held whenever the queue is mutating.  All methods</span><br><span class="line">        # that acquire mutex must release it before returning.  mutex</span><br><span class="line">        # is shared between the three conditions, so acquiring and</span><br><span class="line">        # releasing the conditions also acquires and releases mutex.</span><br><span class="line">        self.mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">        # Notify not_empty whenever an item is added to the queue; a</span><br><span class="line">        # thread waiting to get is notified then.</span><br><span class="line">        self.not_empty &#x3D; threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">        # Notify not_full whenever an item is removed from the queue;</span><br><span class="line">        # a thread waiting to put is notified then.</span><br><span class="line">        self.not_full &#x3D; threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">        # Notify all_tasks_done whenever the number of unfinished tasks</span><br><span class="line">        # drops to zero; thread waiting to join() is notified to resume</span><br><span class="line">        self.all_tasks_done &#x3D; threading.Condition(self.mutex)</span><br><span class="line">        self.unfinished_tasks &#x3D; 0</span><br></pre></td></tr></table></figure></p>
<p><code>Queue</code>会用到如下方法：</p>
<blockquote>
<ul>
<li><strong>put</strong>(): 添加一个项目到队列</li>
<li><strong>get</strong>(): 从队列中取出一个项目</li>
<li><strong>task_done</strong>(): 每处理完一个项目，需要调用该方法</li>
<li><strong>join</strong>(): 阻塞线程，等待全部的任务完成</li>
</ul>
<p><em>附：查看源代码，分析可得Queue内部的操作是这样的：（这段可以不用看）</em></p>
<ul>
<li><em>调用<code>put()</code> -&gt; with队列满(条件锁<code>not_full</code>) -&gt; 能阻塞？(参数block) &amp; 能超时？(参数timeout) &amp; 需要等待？(条件锁<code>not_full.wait()</code>) -&gt; 添加数据(内部方法<code>_put()</code>) -&gt; 任务计数加1(内部计数变量<code>unfinished_tasks += 1</code>) -&gt; 发起队列非空的通知(条件锁<code>not_empty.notify()</code>)</em></li>
<li><em>调用<code>get()</code> -&gt; with队列空(条件锁<code>not_empty</code>) -&gt; 能阻塞？(参数block) &amp; 能超时？(参数timeout) &amp; 需要等待？(条件锁<code>not_empty.wait()</code>) -&gt; 取出数据(内部方法<code>_get()</code>) -&gt; 发起队列非满的通知(条件锁<code>not_full.notify()</code>) （ <strong>注意!</strong> <code>get()</code>与<code>put()</code>操作相比并没有对任务计数操作，需要通过后面<code>task_done()</code>完成任务方法来减少任务数）</em></li>
<li><em>调用<code>task_done()</code> -&gt; with任务完成(条件锁<code>all_tasks_done</code>) -&gt; 判断全部任务完成了？是的话发起通知(条件锁<code>all_tasks_done.notify_all()</code>) -&gt; 任务计数减1(内部计数变量<code>unfinished_tasks -= 1</code>) </em></li>
<li><em>调用<code>join()</code> -&gt; with任务完成(条件锁<code>all_tasks_done</code>) -&gt; 循环未完成的任务计数变量(内部计数变量<code>unfinished_tasks</code>) -&gt; 还有没完成的任务，等待(条件锁<code>all_tasks_done.wait()</code> | 全部完成，退出循环，解除线程阻塞)</em></li>
</ul>
</blockquote>
<p><strong>示例：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">queue = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        item = random.randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">        queue.put(item)</span><br><span class="line">        print(<span class="string">'producer:'</span>, <span class="string">'put'</span>, item)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = queue.get()</span><br><span class="line">        print(<span class="string">'consumer:'</span>, <span class="string">'get'</span>, item)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=producer)</span><br><span class="line">t2 = threading.Thread(target=consumer)</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><del>输出</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer: put 47</span><br><span class="line">consumer: get 47</span><br><span class="line">producer: put 71</span><br><span class="line">consumer: get 71</span><br><span class="line">producer: put 99</span><br><span class="line">consumer: get 99</span><br><span class="line">producer: put 30</span><br><span class="line">consumer: get 30</span><br><span class="line">producer: put 75</span><br><span class="line">consumer: get 75</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>1.后台线程: 后台线程在主线程停止后就直接停止运行。他们资源（如打开的文件，数据库事务等）可能不会被正确的释放。如果你想要你的线程优美的停止，让他们不要变为后台和使用一个合适的信号机制如事件<code>Event</code></p>
<p>2.nvoke: 官方文档中使用invoke一词，我并没有更好的翻译，因为其它语言中invoke反射是一种技术手段，但Google的翻译中，将此解释为调用 <em>（是我想多了）</em></p>
<p>3.加入线程: 加入线程？不理解如何能加入线程，并且官方文档说会死锁。实测，创建2个线程互相join()，虽然陷入死循环，但并没抛出错误    // TODO: 不知理解有偏差没有</p>
<p>4.死锁: 多个对象，互持对方所需资源的锁，导致都无法访问</p>
<p>5.blocking: 锁的acquire()方法的参数，有点难理解，文中所写是结合官方文档和实测的结果描述所得。不过一般，我们都不用改变它的默认值    // TODO: 没有从源码分析（找不到源码）</p>
<p>6.参考书籍：《Python并行编程手册》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/05/python/python-%E5%B9%B6%E8%A1%8C1-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/python/python-%E5%B9%B6%E8%A1%8C1-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">[python 并行1] 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 22:57:03" itemprop="dateCreated datePublished" datetime="2018-10-05T22:57:03+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计并行编程-1"><a href="#设计并行编程-1" class="headerlink" title="设计并行编程 1"></a>设计并行编程 <sup>1</sup></h1><p><strong>任务分解</strong>：将程序分解为任务，在不同处理器上执行以实现并行化。<em>（可以使用以下两种方法）</em></p>
<blockquote>
<ul>
<li><strong>领域分解</strong>：将<code>问题数据</code>分解 <em>（当处理的数据量很大时，分开处理）</em></li>
<li><strong>功能性分解</strong>：将<code>问题</code>分解为任务 <em>（把大的任务分解为多个小任务处理）</em></li>
</ul>
</blockquote>
<p><strong>任务分配</strong>：将任务分配到各个处理器上 <em>（目的是<code>负载均衡</code>）</em></p>
<p><strong>聚集</strong>：将小任务与大任务合并到一起从而改进性能的过程<br>如果任务数量远远超过可用的处理器数量，由于线程切换等其它因素会导致效率降低<br>如果计算机有针对大量小任务而进行特别的设计，如采用GPU计算，那将能从大量小任务的运行中获益</p>
<p><strong>映射</strong>：指定哪个任务将要执行 <em>（目标是将总执行时间降到最低）(可以使用以下2中策略，这2个策略间由于是冲突的，需要做出权衡)</em></p>
<blockquote>
<ul>
<li>通信频繁的任务放在同一个处理器中来增加<code>局部性</code></li>
<li>可以并发执行的任务放在不同的处理器中增加<code>并发性</code></li>
</ul>
</blockquote>
<p><strong>*注意!</strong> 映射问题，即NP完备 <sup>2</sup>。对于相同大小的任务，很容易直接映射<br>如果是每个任务的工作量千差万别，就需要采用<code>负载均衡算法</code>在运行期间确定聚集与映射的策略。<br>如果在程序执行期间通信量或任务量发生变化的情况，可以使用<code>动态的负载均衡算法</code>*</p>
<p><em>（不同的问题存在多种负载均衡算法，有全局或局部的。全局算法需要全局的掌握，会增加大量成本。局部算法只依赖于特定任务本身的信息，不过难以找到最优）<br>（存在 管理者/执行者（管理者调度）、层次化的管理者/执行者（分组，每组都有个管理者调度）、去中心化的模型（每个处理器会维护自己的任务池））</em></p>
<hr>
<h1 id="进程与线程比较-3"><a href="#进程与线程比较-3" class="headerlink" title="进程与线程比较 3"></a>进程与线程比较 <sup>3</sup></h1><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>多线程比多进程成本低，但性能更低</p>
<h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><blockquote>
<h3 id="多进程优点"><a href="#多进程优点" class="headerlink" title="多进程优点"></a>多进程优点</h3><ul>
<li>每个进程相互<strong>独立</strong>，子进程异常不影响父进程</li>
<li>通过增加CPU，就可容<strong>易扩充</strong>性能</li>
<li><strong>没有锁</strong>的影响</li>
<li>每个子进程都有<strong>独立的地址空间和资源</strong><h3 id="多进程缺点"><a href="#多进程缺点" class="headerlink" title="多进程缺点"></a>多进程缺点</h3></li>
<li>逻辑<strong>控制复杂</strong>，需要和主进程交互</li>
<li>需要<strong>跨进程边界</strong>，如有大量数据需要传输不太好，适合少量数据传输、密集运算</li>
</ul>
<h3 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h3><ul>
<li>逻辑<strong>控制简单</strong></li>
<li><strong>无</strong>需跨进程边界</li>
<li>可直接<strong>共享资源</strong></li>
<li>资源消耗比进程<strong>少</strong><h3 id="多线程缺点"><a href="#多线程缺点" class="headerlink" title="多线程缺点"></a>多线程缺点</h3></li>
<li>其中的某个线程崩溃可能会<strong>影响</strong>整个程序</li>
<li>线程之间的同步和<strong>锁</strong>的控制比较麻烦</li>
<li>每个线程与主线程<strong>共用</strong>地址空间</li>
</ul>
</blockquote>
<p><strong>注意!</strong> 无论进程，还是线程多了以后，他们的<strong>调度也会消耗较多的CPU资源</strong></p>
<hr>
<h1 id="python并行编程的问题"><a href="#python并行编程的问题" class="headerlink" title="python并行编程的问题"></a>python并行编程的问题</h1><p>一般来说，一个进程可以包含多个并行线程。不过，Python解释器并非完全是线程安全的。为了支持多线程的Python程序，会使用名为全局解释器锁<code>GIL</code>（Global Interpreter Lock）的<strong>全局锁</strong>。这意味着在同一时刻只有一个线程会执行Python代码。<em>（如果多个线程尝试访问同一个对象数据，那么它可能处于不一致的状态）</em></p>
<p>故此，python中的并行编程想要发挥多核的优势<strong>推荐使用多进程代替多线程</strong></p>
<p>为什么不去除GIL? 更多细节：<a href="https://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python 最难的问题</a></p>
<hr>
<h1 id="python中进程与线程的效率"><a href="#python中进程与线程的效率" class="headerlink" title="python中进程与线程的效率"></a>python中进程与线程的效率</h1><p>由于python自身存在GIL的问题，同一时刻只能运行一个线程，在一些实验对比中，我们会发现python中进程与线程之间的差异，在这里直接给出结论<br>对比操作：<code>CPU密集型</code>、<code>IO密集型</code>、<code>网络请求密集型</code></p>
<blockquote>
<p><strong>多线程</strong></p>
<ul>
<li>CPU密集型操作，性能更差</li>
<li>IO密集型操作，性能更差</li>
<li>网络请求密集型操作，优势明显</li>
</ul>
<p><strong>多进程</strong></p>
<ul>
<li>CPU密集型操作，优势明显</li>
<li>IO密集型操作，优势明显</li>
<li>网络请求密集型操作，与多线程相差无几，却更占用CPU等资源</li>
</ul>
</blockquote>
<p>故CPU密集型、IO密集型操作，首选多进程，网络请求密集型选择多线程</p>
<p><em>（附：如果追求效率，CPU密集型操作应首选<code>C/C++</code>语言<br>IO密集型操作，CPU消耗很少，换用C/C++也很难得到效率的提升，应采用开发效率高的语言，<code>脚本语言</code>是首选）</em></p>
<p>更多细节：<a href="http://www.runoob.com/w3cnote/python-single-thread-multi-thread-and-multi-process.html" target="_blank" rel="noopener">Python中单线程、多线程和多进程的效率对比实验</a></p>
<hr>
<p>1.参考书籍: 《Python并行编程手册》</p>
<p>2.NP完全问题: NP完全问题是世界七大数学难题之一。所有的完全多项式非确定性问题，都可以转换为一类叫做满足性问题的逻辑运算问题。既然这类问题的所有可能答案，都可以在多项式时间内计算，人们于是就猜想，是否这类问题存在一个确定性算法，可以在多项式时间内直接算出或是搜寻出正确的答案呢？这就是著名的NP=P？的猜想（百度百科）<br><a href="https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8（wiki百科）" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8（wiki百科）</a></p>
<p>3.多线程和多进程的区别: 参考：追溯到最早的一篇2011年的页面已失效了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/note/book-list-readed-old/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dejiang">
      <meta itemprop="description" content="你根本不知道你什么都不知道">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫の故事">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/01/note/book-list-readed-old/" class="post-title-link" itemprop="url">book list - readed - old</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">2018-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-26 14:34:40" itemprop="dateModified" datetime="2019-12-26T14:34:40+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/note/" itemprop="url" rel="index">
                    <span itemprop="name">note</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="minder-view" minder-data-type="json" style="width:100%; height:10000px;">

</div>

<script type="text/javascript" src="https://unpkg.com/kity"></script>
<script type="text/javascript" src="https://unpkg.com/kityminder-core"></script>
<script type="text/javascript" src="https://unpkg.com/jquery"></script>

<script type="text/javascript">
        // 创建 km 实例
        /* global kityminder */
        var km = new kityminder.Minder();
        km.setup('.minder-view');
        km.disable();
        km.execCommand('hand');
        $(".km-receiver").remove()
</script>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dejiang"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">dejiang</p>
  <div class="site-description" itemprop="description">你根本不知道你什么都不知道</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wwstory" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wwstory" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1018472917@qq.com" title="E-Mail → mailto:1018472917@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/maplesnow" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;maplesnow" rel="noopener" target="_blank"><i class="fa fa-fw fa-cnblogs"></i>cnblogs</a>
      </span>
  </div>

<!-- old nav -->
<!--
<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
-->



      </div>

      <!-- nav -->
      <nav class="site-nav">
        
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

      </nav>

      <!-- music player -->
      <div>
        
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=0&id=431226116&auto=0&height=32"></iframe>
        
      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dejiang</span>
</div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
